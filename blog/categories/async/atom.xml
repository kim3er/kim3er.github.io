<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Async | Adventures in brine]]></title>
  <link href="http://rich.k3r.me/blog/categories/async/atom.xml" rel="self"/>
  <link href="http://rich.k3r.me/"/>
  <updated>2015-06-16T23:29:45+01:00</updated>
  <id>http://rich.k3r.me/</id>
  <author>
    <name><![CDATA[Richard Kimber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Async/await, Readable Non-blocking Code]]></title>
    <link href="http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code/"/>
    <updated>2015-06-16T23:06:49+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> Shit just got streamlined. More specifically, promises start looking cleaner when you spray them with &lsquo;Callbacks Begone&rsquo;.</em></p>

<p>In this post I&rsquo;m going to give you a quick demo of how easy it is to incorporate ES7&rsquo;s proposed <a href="https://github.com/lukehoban/ecmascript-asyncawait">Async/Await</a> functionality into your existing ES6 code. To build the code, I&rsquo;m using <a href="https://babeljs.io/">Babel</a> with &lsquo;es7.asyncFunctions&rsquo; enabled. You can read about my <a href="https://github.com/gulpjs/gulp">Gulp</a> setup <a href="/blog/2015/03/23/in-the-name-of-gulp/">here</a>.</p>

<!-- More -->


<p>Consider the code below:</p>

<pre><code class="js">function asyncFuncA() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncA'); }, 2000);
  });
}

function asyncFuncB() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncB'); }, 1000);
  });
}

class AsyncController {

  render(template, data) {
    return new Promise(function(resolve, reject) {
      // Do render stuff
      resolve({ t: template, d: data });
    });
  }

  asyncAction(route) {
    return asyncFuncA()
      .then(function(a) {
        return asyncFuncB()
          .then(b =&gt; { return [ a, b ]; });
      })
      .then(data =&gt; { return this.render('route', data); });
  }

}

let c = new AsyncController();

c.asyncAction()
  .then((obj) =&gt; { console.log(`${obj.d[0]} + ${obj.d[1]}`); });
</code></pre>

<p>We&rsquo;re looking at a Controller class with a couple of actions. The <code>asyncAction</code> function of <code>AsyncController</code> is what we&rsquo;re interested in. The action resolves two promises, one after the other, before calling <code>render</code> with the results of the two promises. In a <a href="/blog/2015/04/29/empty-promises-dos-and-donts-of-es6-promises/">previous article</a>, we already removed a couple of callbacks with <code>Promise.all</code>.</p>

<pre><code class="js"> asyncAction(route) {
    return Promise.all([ asyncFuncA(), asyncFuncB() ])
      .then(data =&gt; { return this.render('route', data); });
  }
</code></pre>

<p>A lot cleaner, but we can do better. <code>async</code> and <code>await</code> are keywords that, when used together, allow you to write asynchronous code without callbacks. <code>async</code> creates a container, within which you can execute promises (prefixed with <code>await</code>) that halt the current scope, until the promises have resolved. The resulting values of said promises are returned in the same way would expect a synchronous function to behave.</p>

<p>What is important, is that this only happens within the <code>async</code> container, which is itself becomes a promise. In the following example <code>p</code> and <code>a</code> are roughly equivalent.</p>

<pre><code class="js">function p() {
  return Promise.resolve('hello world');
}

async function a() {
  return 'hello world';
}

p().then((r) =&gt; { console.log(r); });
a().then((r) =&gt; { console.log(r); });
</code></pre>

<p>What I think is particularly neat, is that class functions can also be decorated with <code>async</code>. So we can use this &lsquo;syntastical&rsquo; sugar on our original example to create:</p>

<pre><code class="js">  async asyncAction(route) {
    return this.render(route, [ await asyncFuncA(), await asyncFuncB() ]);
  }
</code></pre>

<p>The code above is equivalent to the <code>asyncAction</code> functions of the previous examples. I mean, pure, wow factor. It&rsquo;s so awesome, I&rsquo;m giddy. Deep breaths, carry on. <code>asyncFuncA</code> and <code>asyncFuncB</code> are both functions that return promises. These promises both return simple strings, after different timeout periods, during which time the <code>asyncAction</code> function&rsquo;s execution is halted. After the promises has resolved, the final value is returned to current scope and execution continues, as if the <code>await</code> functions were synchronous.</p>

<p>This new functionality has taken promises to a whole new level for me. The <code>async</code> function by itself, removes the need for repetitive <code>Promise</code> declarations. Combined with <code>await</code>, we get asynchronous code that is as easy to read as synchronous code. And no callbacks!</p>
]]></content>
  </entry>
  
</feed>
