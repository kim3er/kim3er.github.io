<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Adventures in brine]]></title>
  <link href="http://rich.k3r.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://rich.k3r.me/"/>
  <updated>2015-04-25T10:14:12+01:00</updated>
  <id>http://rich.k3r.me/</id>
  <author>
    <name><![CDATA[Richard Kimber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Consuming ES6 Modules in NPM Packages]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/12/consuming-es6-modules-in-npm-packages/"/>
    <updated>2015-04-12T14:06:12+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/12/consuming-es6-modules-in-npm-packages</id>
    <content type="html"><![CDATA[<p>I&rsquo;m going to have to start coming up with more interesting title for my posts. My eyes are watering at the thought of &lsquo;Consuming ES6 modules in NPM packages&rsquo;. Maybe something more exciting, like &lsquo;Munching on the nuggets of next gen wonderment&rsquo;. I&rsquo;ll work on it.</p>

<p>In this post I&rsquo;m going to describe how you can make use of <a href="https://babeljs.io/">Babel&rsquo;s</a> support for <a href="https://babeljs.io/docs/learn-es6/#modules">ES6 modules</a>, and how you might consume them as <a href="https://www.npmjs.com/">NPM</a> packages. It&rsquo;s pretty neato stuff and makes for very clean code. Read on!</p>

<!-- more -->


<p><em><strong>TL;DR:</strong> Scroll down to the <a href="http://www.starwars.com/">Star Wars</a> reference for the actual tutorial.</em></p>

<p><em><strong>NOTE:</strong> This tutorial has two <a href="https://github.com/">Github</a> repos, <a href="https://github.com/kim3er/example-es6-module">this one</a> and <a href="https://github.com/kim3er/example-module-consumer">this one</a>.</em></p>

<p>Modules have existed in JS space for a while now. I&rsquo;ve dabbled in the past, because I&rsquo;m a big fan of results, I mean who wouldn&rsquo;t be?</p>

<ul>
<li>Keeps junk out of the global scope</li>
<li>Only load what you need</li>
<li>Inferred order of compilation</li>
</ul>


<p>I&rsquo;m just going to pick up on that last point for a moment. While I dabbled, I never really embraced modules as part of a longer term strategy. My reluctance was due to inherent ugliness of implementation, with anything but Node&rsquo;s <code>require</code> and <code>exports</code> syntax. The ugliness is there to make these great ideas work in the browser.</p>

<p>Using the fantastic <a href="https://jquery.com/">jQuery</a> as an example, stuff like:</p>

<pre><code class="js">    if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }
</code></pre>

<p>and</p>

<pre><code class="js">// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" &amp;&amp; define.amd ) {
    define( "jquery", [], function() {
        return jQuery;
    });
}
</code></pre>

<p>and</p>

<pre><code class="js">// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
    window.jQuery = window.$ = jQuery;
}
</code></pre>

<p>I get why it&rsquo;s all there, and I appreciate the efforts teams like jQuery put into compatibility with all of these different systems. I have benefitted from those efforts on many occasions. I bet it&rsquo;s a pain in the backside to maintain, it&rsquo;s very clever, but also, U-G-L-Y.</p>

<h3>Flashback (wavy lines)</h3>

<p>I was drawn back into the fold, as the result of a recent ES6 based project I&rsquo;ve been working on. I was gorging on the beautiful ES6 class syntax, doing a fine job of controlling compilation through the use of sub folders.</p>

<p>As an example, the classes in directories &lsquo;controller&rsquo; and &lsquo;model&rsquo;, inherit from directory &lsquo;base&rsquo;. Classes in &lsquo;controller&rsquo; can reference classes in &lsquo;model&rsquo;, but not the other way around.</p>

<pre><code class="bash">root
    base            &lt;-- Compile first
    controller      &lt;-- Compile third
    model           &lt;-- Compile second
</code></pre>

<pre><code class="js base/base_class.js">class BaseClass {
    parent()  {
        console.log('something interesting');
    }
}
</code></pre>

<pre><code class="js controller/app_controller.js">class AppController extends BaseClass {
    action()  {
        let user = new UserModel();
        console.log('I\'m an action');
    }
}
</code></pre>

<pre><code class="js model/user_model.js">class UserModel extends BaseClass {
    constructor() {
        this.parent();
        console.log('I\'m a model');
    }
}
</code></pre>

<p>This all worked great, better than great, I was king of the world. Until I needed to create <code>BaseController</code>, that extends <code>BaseClass</code> and is extended by <code>AppController</code>.</p>

<pre><code class="js controller/base_controller.js">class BaseController extends BaseClass {
    defaultAction()  {
        console.log('I\'m a default action');
    }
}
</code></pre>

<pre><code class="js controller/app_controller.js">class AppController extends BaseController {
    action()  {
        this.defaultAction();
    }
}
</code></pre>

<p>Due to the dreaded alphabet, <code>AppController</code> compiles before <code>BaseController</code>. Arrrgh. Why world, would you treat me this way?!</p>

<pre><code class="bash">controller
    app_controller.js       &lt;-- Attempts to compile first, but BaseController doesn't exist yet
    base_controller.js      &lt;-- Waits patiently
</code></pre>

<p>Don&rsquo;t tell anyone, but my initial fix was to:</p>

<pre><code class="bash">controller
    0.base_controller.js    &lt;-- Compiles first
    app_controller.js       &lt;-- Compiles second
</code></pre>

<p>I kidded myself for a while that this was a valid design decision, until maybe my third or forth &lsquo;zero dot&rsquo; file. I needed a better way of controlling the order of compilation; it also felt like those base classes could be reused.</p>

<h2>And so, it begins. Destroy them, destroy them all.</h2>

<p>We&rsquo;re going to create two projects; the <a href="https://github.com/kim3er/example-es6-module">module</a> and the <a href="https://github.com/kim3er/example-module-consumer">consumer</a>.</p>

<h3>The module</h3>

<p>The module package will be written in ES6 JavaScript, but will need to be transpilied to ES5, for compatibility. So the ugliness is still there, just hidden. We&rsquo;ll use <a href="http://gulpjs.com/">Gulp</a> and Babel for the build.</p>

<h4>The setup</h4>

<p>I&rsquo;ve created a directory called &lsquo;blog&rsquo;, in here I&rsquo;m writing the following, in terminal:</p>

<pre><code class="bash">mkdir es6-module
cd es6-module
npm init                        &lt;-- Just enter through the defaults
mkdir src
touch gulpfile.js .gitignore
</code></pre>

<p>Your project should look like:</p>

<pre><code class="bash">es6-module
    src                 &lt;-- This is where we\'re going to put our ES6
    .gitignore          &lt;-- We\'ll need to ignore \'node-modules\', when this goes to GIT
    gulpfile.js         &lt;-- Gulp build file
    package.json        &lt;-- This was created when you typed in \'npm init\'
</code></pre>

<p>Make &lsquo;.gitignore&rsquo; look this:</p>

<pre><code class="text .gitignore">node_modules
</code></pre>

<p>Change the <code>main</code> option in &lsquo;package.json&rsquo; to read &lsquo;./lib/index.js&rsquo;. A &lsquo;lib&rsquo; directory will be created as part of the build process, which will contain our ES5 code.</p>

<pre><code class="json">{
    ....
    "main": "./lib/index.js",
    ....
}
</code></pre>

<p><code>main</code> is the entry point to our package. In a consumer, if you were to <code>require('es6-module')</code>, you&rsquo;ll get the exports from the <code>main</code> file.</p>

<h4>The build script</h4>

<p>We need a build script in our &lsquo;gulpfile.js&rsquo;.</p>

<pre><code class="js gulpfile.js">var gulp = require('gulp'),
    del = require('del'),
    babel = require('gulp-babel');

var SRC_PATH = './src',
    LIB_PATH = './lib';

gulp.task('clear', function(cb) {
    del([ LIB_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('build', [ 'clear' ], function() {
    return gulp.src([ SRC_PATH + '/**/*.js' ])
                .pipe(babel({ blacklist: [ 'useStrict' ] }))
                .pipe(gulp.dest(LIB_PATH));
});

gulp.task('default', function() {
    gulp.start('build');
});
</code></pre>

<p>The script has three dependancies:</p>

<ol>
<li>Gulp - The script runner. Like <a href="http://gruntjs.com/">Grunt</a>, but code first.</li>
<li><a href="https://www.npmjs.com/package/del">Del</a> - A little package for deleting stuff.</li>
<li>Babel - ES6 transpiler. Reinvigorated my already deeply unnatural love of JavaScript. Hallelujah.</li>
</ol>


<p>Install the dependancies like so:</p>

<pre><code class="bash">npm install -g gulp babel
npm install --save-dev gulp del gulp-babel
</code></pre>

<p>I think the <code>clear</code> task is self explanatory, so lets talk about <code>build</code>. Typically in a build script, it&rsquo;s tempting to concatenate, but our package is going to benefit from keeping the code in separate files. By keeping the code in separate files, modular, we&rsquo;ll be implementing JavaScript module benefit #2 &lsquo;Only load what you need&rsquo;.</p>

<p>The code itself is transpiled through Babel, to create the ES6 code in &lsquo;lib&rsquo;. I&rsquo;ve blacklisted &lsquo;useStrict&rsquo;. I do this by default, because <code>"use strict"</code> can stop execution in iOS UIWebViews, specifically when using <a href="http://cordova.apache.org/">Cordova</a>.</p>

<h4>The code</h4>

<p>In the src directory, create the following files:</p>

<pre><code class="bash">src
    clever_class.js &lt;-- An example module
    index.js        &lt;-- Our main file
</code></pre>

<pre><code class="js src/clever_class.js">export class CleverClass {
    constructor() {
        console.log('I\'m a clever class');
    }
}
</code></pre>

<pre><code class="js src/index.js">export * from './clever_class';
</code></pre>

<p><em>I think you can already see how useful our new package is going to be.</em></p>

<p><code>CleverClass</code> is pretty unexceptional, except for the addition of <code>export</code> before the <code>class</code> declaration. <code>export</code> tells Babel that we want to reference <code>CleverClass</code> as module.</p>

<p>The code in &lsquo;index.js&rsquo; is really interesting. We&rsquo;re literally creating an index to all modules in our package, that we want made public. <code>export * from</code> (not <code>import</code>), re-exports <code>CleverClass</code> as part of &lsquo;index.js&rsquo;.</p>

<p>Think about the implications here. You can have twenty different classes in this directory, all extending each other in different and exciting ways. From &lsquo;index.js&rsquo;, you choose which of those classes make it to your public API. <code>CleverClass</code> may inherit from a class called <code>BaseClass</code>, but only <code>CleverClass</code> is accessible, even though <code>CleverClass</code> still benefits from the existence of <code>BaseClass</code>.</p>

<p><em>At this point, you&rsquo;re starting to feel like Skeletor, just before he was robbed of the powers of Grey Skull.</em></p>

<p>Okay, build the mutha:</p>

<pre><code class="bash">gulp build
</code></pre>

<p>Any errors? No, great. You should now have a &lsquo;lib&rsquo; directory that mirrors the structure of &lsquo;src&rsquo;, just with ES5 code, instead of ES6.</p>

<p><em><strong>NOTE:</strong> This feels a bit &lsquo;fly-by the seat of your pants&rsquo; coding. Usually I&rsquo;d have a test suite in the project, to ensure that we&rsquo;re all rocking in the right direction. However, we&rsquo;re about to build a consumer for exactly that, and for the purposes of this tutorial I wanted to keep concerns clean and avoid duplication. You dig?</em></p>

<h3>The consumer</h3>

<p>The purpose of this tutorial is to demonstrate how you can consume ES6 modules, contained within an NPM package. To do this, we need a separate project, from which to consume the package; this is that project.</p>

<h4>The setup</h4>

<p>From the blog directory:</p>

<pre><code class="bash">mkdir module-consumer
cd module-consumer
npm init                        &lt;-- Just enter through the defaults
mkdir app
touch gulpfile.js .gitignore
</code></pre>

<p>Here is our &lsquo;.gitignore&rsquo;:</p>

<pre><code class="text .gitignore">.web
node_modules
</code></pre>

<p>Here is our directory structure:</p>

<pre><code class="bash">module-consumer
    app                 &lt;-- This is where we\'re going to put our test app
    .gitignore          &lt;-- We'll need to ignore \'node-modules\', when this goes to GIT
    gulpfile.js         &lt;-- Gulp build file
    package.json        &lt;-- This was created when you typed in \'npm init\'
</code></pre>

<h4>The build script</h4>

<p>Our test app is going to be a very simple website, so we&rsquo;re going to need a web server, in this case <a href="https://github.com/senchalabs/connect">Connect</a>. Because we&rsquo;re using a website as our testbed, we need to a way to consume the NPM package in a way that the browser understands; for this, we will use <a href="http://browserify.org/">Browserify</a>.</p>

<pre><code class="js gulpfile.js">var gulp = require('gulp'),
    connect = require('gulp-connect'),
    del = require('del'),
    watch = require('gulp-watch'),
    runSequence = require('run-sequence'),
    babelify = require('babelify'),
    browserify = require('browserify'),
    source = require('vinyl-source-stream');

var APP_PATH = './app',
    WEB_PATH = './.web';

gulp.task('clear', function(cb) {
    del([ WEB_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('js', function() {
    return browserify({
                    entries: APP_PATH + '/app.js',
                    debug: true
                })
                .transform(babelify)
                .bundle()
                .pipe(source('app.js'))
                .pipe(gulp.dest(WEB_PATH));
});

gulp.task('index', function() {
    return gulp.src([ APP_PATH + '/index.html' ])
        .pipe(gulp.dest(WEB_PATH));
});

gulp.task('connect', function(cb) {
    connect.server({
        root: WEB_PATH,
        livereload: true
    });

    cb();
});

gulp.task('livereload', function () {
    return gulp.src( WEB_PATH + '/**/*' )
        .pipe(connect.reload());
});

gulp.task('serve', [ 'clear' ], function(cb) {
    runSequence(
        [ 'js', 'index' ],
        'connect',
        function() {            
            watch([ APP_PATH + '/app.js' ], function() { gulp.start('js'); });
            watch([ APP_PATH + '/index.html' ], function() { gulp.start('index'); });
            watch([ WEB_PATH + '/**/*' ], function() { gulp.start('livereload'); });

            cb();
        }
    );
});
</code></pre>

<p>The script has these dependancies:</p>

<ol>
<li>Gulp</li>
<li>Gulp Connect - Our web server.</li>
<li>Del</li>
<li><a href="https://www.npmjs.com/package/gulp-watch">Gulp Watch</a> - Kicks off Gulp tasks, when a file changes.</li>
<li><a href="https://www.npmjs.com/package/run-sequence">Run Sequence</a> - Asynchronous task management. <a href="/blog/2015/03/23/in-the-name-of-gulp/">Read my blog</a>.</li>
<li><a href="https://github.com/babel/babelify">Babelify</a> - Babel transformer for Browserify.</li>
<li>Browserify - Makes Node&rsquo;s <code>require</code> work in the browser.</li>
<li><a href="https://www.npmjs.com/package/vinyl-source-stream">Vinyl Source Stream</a> - Makes Browserify work with Gulp.</li>
</ol>


<p>Install them:</p>

<pre><code class="bash">npm install --save-dev gulp gulp-connect del gulp-watch run-sequence babelify browserify vinyl-source-stream
</code></pre>

<p>Here&rsquo;s a quick rundown of the tasks in this script:</p>

<h5>js</h5>

<p>Transpiles and concatenates the contents of &lsquo;app/app.js&rsquo; (not created yet), using Browserify. Browserify follows every <code>require</code>, creates a virtual tree, then bundles all the code in one file.</p>

<p><em>I mean, wow, just wow.</em></p>

<p>We&rsquo;re not using the <code>require</code> syntax though, so we need Babelify. Babelify transforms/transpiles the ES6 syntax to ES5, for Browserify to understand.</p>

<p>The result of which is outputted to our temporary web directory (&lsquo;.web&rsquo;, which doesn&rsquo;t exist yet).</p>

<h5>index</h5>

<p>Moves &lsquo;app/index.html&rsquo; to &lsquo;.web/index.html&rsquo;. You don&rsquo;t want to be working directly in &lsquo;.web&rsquo;.</p>

<h5>connect</h5>

<p>Uses Connect to start a web server, with <a href="http://livereload.com/">Live Reload</a>.</p>

<h5>livereload</h5>

<p>Reacts to file changes. Live Reload reloads your browser programmatically. It&rsquo;s pure magic.</p>

<h5>serve</h5>

<p>This is what we type into terminal. It&rsquo;s a &lsquo;stitch everything together task&rsquo;. We use Run Sequence to run our two compilation tasks, <code>js</code> and <code>index</code>, before kicking off the web server task <code>connect</code>. Finally, we set off the file watchers, that react accordingly to file changes.</p>

<h4>The code</h4>

<p>I&rsquo;m going to start by boilerplating &lsquo;index.html&rsquo; in the &lsquo;app&rsquo; directory; the sole point of this file is to load &lsquo;app.js&rsquo;.</p>

<pre><code class="html app/index.html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="./app.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Here&rsquo;s &lsquo;app.js&rsquo;.</p>

<pre><code class="js app/app.js">// Example 1: Namespace
import * as es6 from 'es6-module';

new es6.CleverClass();


// Example 2: Choose exports
// import { CleverClass } from 'es6-module';

// new CleverClass();


// Example 3: Target individual files
// import { CleverClass } from 'es6-module/lib/clever_class';

// new CleverClass();
</code></pre>

<p>&lsquo;app.js&rsquo; contains three examples of how can access &lsquo;CleverClass&rsquo; from our first project&hellip; Aww crap, hang on a minute, we&rsquo;ve not actually referenced our &lsquo;es6-module&rsquo; package!</p>

<pre><code class="bash">npm install --save-dev ../es6-module
</code></pre>

<p><em><strong>NOTE:</strong> NPM allows you to install local packages, that&rsquo;s what going on in the code above.</em></p>

<p>What was I saying? Right, three examples. They should all have the same result, but show the flexibility was the ES6 way of doing modules:</p>

<ol>
<li>Namespace - Using <code>as</code>, you can wrap your imports in a namespace. Very tidy.</li>
<li>Be selective - You may only want to use one or two classes, list them in curly brackets!</li>
<li>Don&rsquo;t pull in the whole library - Prepare to have your mind blown. &lsquo;Boom&rsquo;. You can reference individual modules within the package. Don&rsquo;t say a word, it&rsquo;s alright, I know. #shhh</li>
</ol>


<p>Run the server and breath in the sweet, sweet smell of success.</p>

<pre><code class="bash">gulp serve
</code></pre>

<p>I accept the payoff is a little underwhelming. If all is well, when you open you dev tool in a browser, pointed at <a href="http://localhost:8080">http://localhost:8080</a>, you should see:</p>

<pre><code class="text">I'm a clever class
</code></pre>

<h3>The conclusion</h3>

<p>That&rsquo;s not the point. The point is, &ldquo;I&rsquo;m a clever class&rdquo; was written in module in one package, and accessed from a script in another. All the code was written in ES6, and only the files needed, were accessed in the test site.</p>

<p>We&rsquo;ve gained:</p>

<ol>
<li>A modular build.</li>
<li>A reusable library.</li>
<li>Only compile what you use.</li>
<li>Future proofing, with ES6 compatible base code.</li>
</ol>


<p>We. Are. Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controlling Cordova From Gulp]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp/"/>
    <updated>2015-04-02T22:39:27+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp</id>
    <content type="html"><![CDATA[<p>It&rsquo;s a story as old as time. Girl meets boy, boy has an annoying two step build process, spread across two directories. Of course I&rsquo;m talking about having an awesome <a href="http://gulpjs.com/">Gulp</a> workflow, with a Cordova project clumsily tacked on the side. Well, no more, now you can integrate <a href="http://cordova.apache.org/">Cordova</a>! into Gulp! Yay!</p>

<!-- more -->


<p><em><strong>NOTE:</strong> You see the code over at <a href="https://github.com/kim3er/cordova-gulp">Github</a>.</em></p>

<p>Let&rsquo;s discuss the problem first. Until recently, Gulp and Cordova were two separate Node based, command line powered worlds to me, with seemingly nothing in common. In the given scenario, I&rsquo;d typically have a two directory structure:</p>

<pre><code>app             &lt;-- Source files for the project
cordova         &lt;-- Cordova root directory
    - www       &lt;-- Cordova app directory
gulpfile.js
</code></pre>

<p>Gulp would take care of transpiling the code in the <code>app</code> directory and transferring the spoils to <code>cordova/www</code>. Cordova is then responsible for building the Cordova project and delivering the app to an emulator.  Something like:</p>

<pre><code class="bash">gulp
cd ./cordova
cordova emulate
cd ../
</code></pre>

<p>Before switching to Gulp, I used to use Middleman for a lot of the transpiling tasks, where I&rsquo;d maintain a number of bash scripts to create the illusion of cohesion. It didn&rsquo;t feel right when I switched to Gulp though. There must be some similarity between these disparate Node based, command line tools. What was I missing?</p>

<p>You know what I realised? That Gulp is based on Node and so is Cordova; so I can probably access Cordova directly from within my Gulp task. It&rsquo;s never going to be that easy, is it?</p>

<p>Well, it&rsquo;ll be a disappointment if it wasn&rsquo;t that easy. So long story short, it almost is. To demonstrate, I&rsquo;m going to cook up a quick project, to demonstrate the integration:</p>

<pre><code class="bash">npm init
touch gulpfile.js
npm install -g cordova gulp ios-deploy
npm install --save-dev gulp cordova-lib del
cordova create ./cordova me.k3r.cordgulp CordovaGulp
</code></pre>

<p>Accept all the defaults on <code>npm install</code>, if you&rsquo;re not sure how to answer. All it does is create your <code>package.json</code> and settings can be easily changed at any time.</p>

<p>The <code>-g</code> means install globally, and the <code>--save-dev</code> will save the packages as development dependancies within the <code>package.json</code>. Have a look, you&rsquo;ll see what I mean.</p>

<p><a href="https://github.com/phonegap/ios-deploy">ios-deploy</a> is neat if you&rsquo;re on a Mac and want to deploy from script or command line to iOS.</p>

<p>The last line scaffolds a basic Cordova project.</p>

<p>Paste in the following to your newly created <code>gulpfile.js</code>, but don&rsquo;t run anything yet!</p>

<pre><code class="js">var gulp = require('gulp')
    del = require('del'),
    cordova = require('cordova-lib').cordova.raw;

var APP_PATH = './app',
    CORDOVA_PATH = './cordova/www';

gulp.task('del-cordova', function(cb) {
    del([ CORDOVA_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('compile', [ 'del-cordova' ], function(cb) {
    return gulp.src([ APP_PATH + '/**/*' ])
        .pipe(gulp.dest(CORDOVA_PATH));
});

gulp.task('build', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .build()
        .then(function() {
            process.chdir('../');
            cb();
        });
});

gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<p>If you ran anything at the point, you&rsquo;d replace the default Cordova <code>www</code> directory with that stark emptiness of your nonexistent <code>app</code> directory. Remedy that with the following, which moves the contents of <code>cordova/www</code> to <code>app</code>.</p>

<pre><code class="bash">mv ./cordova/www ./app
</code></pre>

<p>You now have the almost complete example. If you type in <code>gulp compile</code>, <code>cordova/www</code> will be recreated with the contents of <code>app</code>. Nothing else is going on here at the moment, but think of the possibilities.</p>

<p>We haven&rsquo;t quite finished yet. Type in the following, to add iOS and/or Android as platforms to your new project.</p>

<pre><code class="bash">cd cordova
cordova platform add ios
cd ../
</code></pre>

<p>While you&rsquo;re in the <code>cordova</code> directory, you could have also run <code>cordova build</code> or <code>cordova emulate ios</code>, but that&rsquo;s for losers.</p>

<p>Within in the project root, run either of these bad boys:</p>

<pre><code class="bash">gulp build
gulp emulate
</code></pre>

<p>That&rsquo;s right, one command to rule them all. <code>gulp emulate</code> transpiles the code, moves it to <code>cordova/www</code> then kicks off the Cordova <code>build</code> and <code>emulate</code> commands.</p>

<p>&ldquo;But how does this sorcery work?&rdquo; I hear you cry. Cordova developers will mostly recognise Cordova&rsquo;s <a href="https://www.npmjs.com/">NPM</a> package as a command line tool, but as such a package, we should also be able to require it within a Node script (or in this case, Gulp). The reference here, <code>cordova = require('cordova-lib').cordova.raw</code>, provides access to the Cordova&rsquo;s underlying API, exposing stuff like <code>build</code> and <code>emulate</code>.</p>

<p>It&rsquo;s not all unicorns mind; the API has auto-detection routine in place that works out the project&rsquo;s root directory. This only works however, if you&rsquo;re within Cordova&rsquo;s project structure. I&rsquo;m positive this can be overcome by &lsquo;cleaner&rsquo; methods of API abstraction, but for the moment I&rsquo;ve circumvented the issue by introducing two calls to <code>process.chdir</code>. <code>chdir</code> changes the working directory of running script. The second call resets the directory, for the purposes of possible task chaining.</p>

<p>See here:</p>

<pre><code class="js">gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<ol>
<li>We change the directory.</li>
<li>We call <code>run</code>. <code>emulate</code> is an alias for <code>run</code>.</li>
<li>When the <code>run</code> process completes, the directory is reset.</li>
</ol>


<p>So there you have it, in a single Gulp command you can, transpile, populate, build and emulate. For me, this little nugget has sped up my workflow, and has made the build task more approachable to other developers working on the project.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[In the Name of Gulp]]></title>
    <link href="http://rich.k3r.me/blog/2015/03/23/in-the-name-of-gulp/"/>
    <updated>2015-03-23T22:41:47+00:00</updated>
    <id>http://rich.k3r.me/blog/2015/03/23/in-the-name-of-gulp</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> Use Gulp 4 if you care about task management. If you can&rsquo;t use Gulp 4, use Gulp 3 with &lsquo;runSequence&rsquo;. Also, I need to start reading documentation more and assuming less.</em></p>

<p><em><strong>NOTE:</strong> You see the code over at <a href="https://github.com/kim3er/gulp-4-demo">Github</a>.</em></p>

<p>The release of Gulp 4 is right around the corner, but you can already use it on the <a href="https://github.com/gulpjs/gulp/tree/4.0">4.0 branch</a>. Here is why you should.</p>

<!-- more -->


<h2>Feelings of inadequacy</h2>

<p>When <a href="http://gruntjs.com/">Grunt</a> gained popularity, I was excited by the premise, but underwhelmed by the execution. I feel this is more due to a deficiency on my part, rather than an actual problem with Grunt, given the <a href="http://gruntjs.com/development-team">team</a> behind it. Just looking at the <a href="http://gruntjs.com/getting-started">Getting Started</a> page causes static to course through my brain. #brains</p>

<p>This feeling of inadequacy stayed with me until I found <a href="https://github.com/gulpjs/gulp">Gulp</a>. Gulp&rsquo;s barrier to entry seems a lot lower than Grunt&rsquo;s, it&rsquo;s really a tool you can just run with. Now I feel great about myself, now that I&rsquo;ve found &lsquo;my people&rsquo;. Amen brothers and sisters, this is the house of Gulp.</p>

<h2>Asynchronous shrubs</h2>

<p>It&rsquo;s not all roses in the garden of Gulp 3 though, well maybe it is, but those roses have thorns. And those thorns all bare the words &lsquo;async callbacks&rsquo;. If you&rsquo;ve ever considered Gulp tasks to be modular, building blocks of larger tasks, then you&rsquo;ve probably faced the same disappointment that I have, that they&rsquo;re not.</p>

<p>Take this simple gulpfile:</p>

<pre><code class="js">var gulp = require('gulp')
    sass = require('gulp-sass'),
    babel = require('gulp-babel'),
    del = require('del');

var DEST = './dest',
    SRC = './src';

gulp.task('clean', function(cb) {
    del(DEST, cb);
});

gulp.task('stylesheets', function() {
    return gulp.src(SRC + '/app.scss')
        .pipe(sass())
        .pipe(gulp.dest(DEST));
});

gulp.task('javascripts', function() {
    return gulp.src(SRC + '/app.js')
        .pipe(babel({ blacklist: [ 'useStrict' ] }))
        .pipe(gulp.dest(DEST));
});

gulp.task('html', function() {
    return gulp.src(SRC + '/app.html')
        .pipe(gulp.dest(DEST));
});

gulp.task('default', [ 'clean', 'stylesheets', 'javascripts', 'html' ], function() {

});
</code></pre>

<p>The script above takes the contents of <code>src</code> and sticks it in <code>dest</code>. There is a problem with the script above, that becomes apparent when you check the output:</p>

<pre><code class="bash">[22:02:10] Starting 'clean'...
[22:02:10] Starting 'stylesheets'...
[22:02:10] Starting 'javascripts'...
[22:02:10] Starting 'html'...
[22:02:10] Finished 'clean' after 23 ms
[22:02:10] Finished 'javascripts' after 48 ms
[22:02:10] Finished 'html' after 45 ms
[22:02:10] Finished 'stylesheets' after 55 ms
[22:02:10] Starting 'default'...
[22:02:10] Finished 'default' after 12 μs
</code></pre>

<p>Look at the fifth entry, it&rsquo;s the <code>clean</code> task finishing after 23 milliseconds, after all the other tasks have already started. So the clean script is still deleting stuff after the other tasks have started moving their stuff across.</p>

<h2>Something funny about iteration</h2>

<pre><code class="js">gulp.task('default', [ 'clean' ], function() {
    [ 'stylesheets', 'javascripts', 'html' ].forEach(function(taskName) {
        gulp.start(taskName);
    });
});
</code></pre>

<p>With the <code>default</code> task above, the <code>clean</code> task will complete before any other task starts; no more conflict. Thing is though, looking at the output, the <code>default</code> task is the first to finish after <code>clean</code>. Because Gulp tasks are asynchronous (non blocking), the <code>default</code> task has no reason to hang around waiting for all the tasks in the <code>forEach</code> to complete; the code is only interested in starting each task. This isn&rsquo;t a big deal in our example, but what if you then needed to add a third step?</p>

<pre><code class="js">gulp.task('build', [ 'clean' ], function(cb) {
    [ 'stylesheets', 'javascripts', 'html' ].forEach(function(taskName) {
        gulp.start(taskName);
    });
    cb();
});

gulp.task('deploy', [ 'build' ], function() {
    console.log('deploy!');
});

gulp.task('default', [ 'deploy' ], function() {

});
</code></pre>

<p>Check out the output:</p>

<pre><code class="bash">[22:28:20] Starting 'clean'...
[22:28:20] Finished 'clean' after 8.59 ms
[22:28:20] Starting 'build'...
[22:28:20] Starting 'stylesheets'...
[22:28:20] Starting 'javascripts'...
[22:28:20] Starting 'html'...
[22:28:20] Finished 'build' after 10 ms
[22:28:20] Starting 'deploy'...
deploy!
[22:28:20] Finished 'deploy' after 59 μs
[22:28:20] Starting 'default'...
[22:28:20] Finished 'default' after 2.89 μs
[22:28:20] Finished 'html' after 42 ms
[22:28:20] Finished 'javascripts' after 45 ms
[22:28:20] Finished 'stylesheets' after 52 ms
</code></pre>

<p>The <code>deploy</code> task finishes before the <code>build</code> tasks have completed, which is obviously not ideal!</p>

<h2>My &lsquo;go to&rsquo; for async code (given up on the &lsquo;humor&rsquo;)</h2>

<p>I had expected to find that the <code>start</code> function would support a callback or even an event emitter. That being the case, we could use something like <a href="https://github.com/caolan/async">async</a> (a neat package for dealing with asynchronous code) to do something like:</p>

<pre><code class="js">    async
        .eachSeries(
            [ 'stylesheets', 'javascripts', 'html' ],
            function(taskName, callback) {
                gulp.start(taskName, function() { callback(); });
                // or
                // gulp.start(taskName).on('end', callback);
            },
            function(err) {
                cb()
            }
        );
</code></pre>

<p>But alas, not. The <code>start</code> function is fire and forget. In the example above, crazy stuff happens in the output:</p>

<pre><code class="bash">[20:34:15] Starting 'clean'...
[20:34:15] Finished 'clean' after 8.25 ms
[20:34:15] Starting 'build'...
[20:34:15] Starting 'stylesheets'...
[20:34:15] Finished 'stylesheets' after 25 ms
</code></pre>

<h2>&lsquo;runSequence&rsquo;, a beautiful stopgap</h2>

<p>What you need, is an unassuming, wicked little plugin called <a href="https://www.npmjs.com/package/run-sequence">run-sequence</a>. Using &lsquo;run-sequence&rsquo;, you can do something like:</p>

<pre><code class="js">gulp.task('build', [ 'clean' ], function(cb) {
    runSequence(
        [ 'stylesheets', 'javascripts', 'html' ],
        cb
    );
});
</code></pre>

<p>You can see from the output that we get exactly what we want:</p>

<pre><code class="bash">[20:41:34] Starting 'clean'...
[20:41:34] Finished 'clean' after 8.18 ms
[20:41:34] Starting 'build'...
[20:41:34] Starting 'stylesheets'...
[20:41:34] Starting 'javascripts'...
[20:41:34] Starting 'html'...
[20:41:34] Finished 'html' after 44 ms
[20:41:34] Finished 'stylesheets' after 54 ms
[20:41:34] Finished 'javascripts' after 49 ms
[20:41:34] Finished 'build' after 56 ms
[20:41:34] Starting 'deploy'...
deploy!
[20:41:34] Finished 'deploy' after 81 μs
[20:41:34] Starting 'default'...
[20:41:34] Finished 'default' after 3.88 μs
</code></pre>

<p>&lsquo;run-sequence&rsquo; is cool, but there is a better way.</p>

<h2>The point of the post</h2>

<p>Gulp 4 uses <a href="https://github.com/phated/undertaker">undertaker</a> for task management. This is significant because &lsquo;undertaker&rsquo; supports the chaining of series and parallel tasks. In order to make use of this functionality, you need to install the prerelease version of Gulp, which is easily done by following this <a href="http://demisx.github.io/gulp4/2015/01/15/install-gulp4.html">guide</a>.</p>

<p>You can see examples of series and parallel functionality, <a href="https://github.com/gulpjs/gulp/blob/4.0/docs/recipes/running-tasks-in-series.md">here</a>, but check this out:</p>

<pre><code class="js">gulp.task('build', gulp.series('clean', 'stylesheets', 'javascripts', 'html'));

gulp.task('deploy', gulp.series('build', function(cb) {
    console.log('deploy!');
    cb();
}));

gulp.task('default', gulp.series('deploy'));
</code></pre>

<p>The difference here is that the dependancies array and callback have been replaced with chain-able <code>series</code> functions. You can see from the output below that, while the <code>deploy</code> task appears to start too early, the <code>console.log</code> demonstrates that the meat and veg of the task runs when it needs to.</p>

<pre><code class="bash">[21:39:29] Starting 'default'...
[21:39:29] Starting 'deploy'...
[21:39:29] Starting 'build'...
[21:39:29] Starting 'clean'...
[21:39:29] Finished 'clean' after 8.95 ms
[21:39:29] Starting 'stylesheets'...
[21:39:29] Finished 'stylesheets' after 17 ms
[21:39:29] Starting 'javascripts'...
[21:39:29] Finished 'javascripts' after 32 ms
[21:39:29] Starting 'html'...
[21:39:29] Finished 'html' after 2.98 ms
[21:39:29] Finished 'build' after 62 ms
[21:39:29] Starting '&lt;anonymous&gt;'...
deploy!
[21:39:29] Finished '&lt;anonymous&gt;' after 222 μs
[21:39:29] Finished 'deploy' after 63 ms
[21:39:29] Finished 'default' after 65 ms
</code></pre>

<p>To sum up. Gulp 4 is a huge step forward in terms of task management. I&rsquo;ve had no problems with v4 so far, but if you need to hang with v3 for a little while longer, &lsquo;run-sequence&rsquo; is a good option.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[localForage for Cross-platform Storage]]></title>
    <link href="http://rich.k3r.me/blog/2015/02/28/localforage-for-cross-platform-storage/"/>
    <updated>2015-02-28T09:30:05+00:00</updated>
    <id>http://rich.k3r.me/blog/2015/02/28/localforage-for-cross-platform-storage</id>
    <content type="html"><![CDATA[<p><em>TL;DR: You should be using <a href="https://mozilla.github.io/localForage/">localForage</a> for all your web based local storage needs. It&rsquo;s wonderful.</em></p>

<p>Storage in general is a bit of a tricky one in hybrid development. There are three main types of storage (excluding bespoke implementations and filesystem) you potentially have access to in a web based development:</p>

<!-- more -->


<h2>localStorage</h2>

<p>Until recently, my &ldquo;go to guy&rdquo; for app storage. localStorage is really easy to use key-value storage, that is at the time of writing, the only consistent cross-platform storage mechanism. The problem with localStorage though, is that you typically only get access to 5MB. This has always been sufficient for my needs in the past, but you can&rsquo;t help thinking that&rsquo;s a scalability problem waiting to happen. The limit speaks to the intended use for this sort of storage; if you&rsquo;ve a lot of data, look somewhere else.</p>

<pre><code class="javascript">localStorage.setItem('key', 'value');
</code></pre>

<p><a href="http://caniuse.com/#feat=namevalue-storage">Compatibility</a></p>

<h2>WebSQL</h2>

<p>WebSQL is an implementation of Sqlite, which is great, because I love Sqlite. What is not so great is that there is no support for IE/Firefox, and non seemingly on the horizon. I suspect it&rsquo;s due to the lack of involvement from two major vendors, that <a href="http://en.wikipedia.org/wiki/Web_SQL_Database">W3C ceased working on the specification in November 2010</a>. No more to be said.</p>

<pre><code class="javascript">
var database = openDatabase('testDB', '1.0', 'Test Database', 1024 * 1024);
database.transaction(function (transaction) {
   transaction.executeSql('CREATE TABLE IF NOT EXISTS entries (id INTEGER PRIMARY KEY, value VARCHAR)');
   transaction.executeSql('INSERT INTO entries (value) VALUES ("value")');
});
</code></pre>

<p><a href="http://caniuse.com/#feat=sql-storage">Compatibility</a></p>

<h2>IndexedDB</h2>

<p>IndexedDB has gained <a href="http://www.girliemac.com/blog/2014/07/03/indexeddb/">greater platform support of late</a>. Even so, with support having only just been implemented in iOS &amp; Android, legacy support is an issue. The Blob support is really interesting. But actually, beyond what I&rsquo;ve read, I don&rsquo;t know too much about IndexedDB, I&rsquo;ve never really used it.</p>

<p><em>NOTE: I went hunting around for an example for IndexedDB, the best article I came across was <a href="http://code.tutsplus.com/tutorials/working-with-indexeddb--net-34673">this one</a>.  Wow, is IndexedDB long winded or what?!</em></p>

<p><a href="http://caniuse.com/#feat=indexeddb">Compatibility</a></p>

<p>So, which storage mechanism am I using? Well, I&rsquo;m probably using IndexedDB in most cases. Ehh? I recently had call to convert a Cordova app to a Chrome app. The app in question was using localStorage. Trick is, Chrome apps don&rsquo;t support standard localStorage. They have their own version (called <a href="https://developer.chrome.com/apps/storage">chrome.storage</a>) that is very similar to localStorage, but is asynchronous nature. I didn&rsquo;t really want to rewrite the whole data layer specifically to work with Chrome app, but I found the idea of making it  asynchronous appealing . Maybe it was time to break my reliance on localStorage.</p>

<p>I found <a href="https://mozilla.github.io/localForage/">localForage</a>, a Mozilla library that wraps localStorage, WebSQL and IndexedDB into asynchronous localStorage API. Perfect! The library basically uses whatever is available; You can even set or of precedence and write your own adapters (I&rsquo;m thinking <a href="https://developer.chrome.com/apps/storage#property-sync">chrome.storage.sync</a>).</p>

<p>Below is a fragment of the code I&rsquo;ve converted to use localForage. The JavaScript is written using ES6.</p>

<pre><code class="javascript">class InternalStorage {

    constructor(key) {
        this._storage = localStorage;
    }

    _serialize(data) {
        return JSON.stringify(data);
    }

    _deserialize(value) {
        return JSON.parse(value);
    }

    _getIndexKey() {
        return this._key + '-index';
    }

    getIndex() {
        var value = this._storage.getItem(this._getIndexKey());

        if (value) {
            return this._deserialize(value);
        }
        else {
            return [];
        }
    }

    setIndex(array=[]) {
        var obj = this._serialize(array);
        return this._storage.setItem(this._getIndexKey(), obj);
    }

}
</code></pre>

<p>Here is the converted code, using localForage:</p>

<pre><code class="javascript">class InternalStorage {

    constructor(key) {
        this._storage = localforage;
    }

    _serialize(data) {
        return data;
    }

    _deserialize(value) {
        return value;
    }

    _getIndexKey() {
        return this._key + '-index';
    }

    getIndex() {
        var self = this;

        return new Promise(function(resolve, reject) {
            self._storage.getItem(self._getIndexKey())
                .then((value) =&gt; { resolve(self._deserialize(value)); });
        });
    }

    setIndex(array=[]) {
        var obj = this._serialize(array);
        return this._storage.setItem(this._getIndexKey(), obj);
    }

}
</code></pre>

<p>The things to notice with the transition to localForage are:</p>

<ul>
<li>No requirement to serialise/deserialise, as localForage deals with this.</li>
<li>localForage returns an ES6 Promise, so, so does <code>setIndex</code>.</li>
<li>I&rsquo;ve wrapped the logic for <code>getIndex</code> in a Promise, so I can keep my <code>_serialize</code> method in place. Well, you never know.</li>
</ul>


<p>ES6 is a big thing for me at the moment, so the fact that localForage supports ES6 compliant promises, was very appealing. The ability to write additional adapters adds future proofing. My one gripe, which isn&rsquo;t an issue with localForage, is that we don&rsquo;t have a robust solution for relational storage in our web based development at the moment.</p>
]]></content>
  </entry>
  
</feed>
