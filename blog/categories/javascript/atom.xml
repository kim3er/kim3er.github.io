<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Adventures in brine]]></title>
  <link href="http://rich.k3r.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://rich.k3r.me/"/>
  <updated>2015-04-02T22:41:53+01:00</updated>
  <id>http://rich.k3r.me/</id>
  <author>
    <name><![CDATA[Richard Kimber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Controlling Cordova From Gulp]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp/"/>
    <updated>2015-04-02T22:39:27+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp</id>
    <content type="html"><![CDATA[<p>It&rsquo;s a story as old as time. Girl meets boy, boy has an annoying two step build process, spread across two directories. Of course I&rsquo;m talking about having an awesome <a href="http://gulpjs.com/">Gulp</a> workflow, with a Cordova project clumsily tacked on the side. Well, no more, now you can integrate <a href="http://cordova.apache.org/">Cordova</a>! into Gulp! Yay!</p>

<!-- more -->


<p><em><strong>NOTE:</strong> You see the code over at <a href="https://github.com/kim3er/cordova-gulp">Github</a>.</em></p>

<p>Let&rsquo;s discuss the problem first. Until recently, Gulp and Cordova were two separate Node based, command line powered worlds to me, with seemingly nothing in common. In the given scenario, I&rsquo;d typically have a two directory structure:</p>

<pre><code>app             &lt;-- Source files for the project
cordova         &lt;-- Cordova root directory
    - www       &lt;-- Cordova app directory
gulpfile.js
</code></pre>

<p>Gulp would take care of transpiling the code in the <code>app</code> directory and transferring the spoils to <code>cordova/www</code>. Cordova is then responsible for building the Cordova project and delivering the app to an emulator.  Something like:</p>

<pre><code class="bash">gulp
cd ./cordova
cordova emulate
cd ../
</code></pre>

<p>Before switching to Gulp, I used to use Middleman for a lot of the transpiling tasks, where I&rsquo;d maintain a number of bash scripts to create the illusion of cohesion. It didn&rsquo;t feel right when I switched to Gulp though. There must be some similarity between these disparate Node based, command line tools. What was I missing?</p>

<p>You know what I realised? That Gulp is based on Node and so is Cordova; so I can probably access Cordova directly from within my Gulp task. It&rsquo;s never going to be that easy, is it?</p>

<p>Well, it&rsquo;ll be a disappointment if it wasn&rsquo;t that easy. So long story short, it almost is. To demonstrate, I&rsquo;m going to cook up a quick project, to demonstrate the integration:</p>

<pre><code class="bash">npm init
touch gulpfile.js
npm install -g cordova gulp ios-deploy
npm install --save-dev gulp cordova-lib del
cordova create ./cordova me.k3r.cordgulp CordovaGulp
</code></pre>

<p>Accept all the defaults on <code>npm install</code>, if you&rsquo;re not sure how to answer. All it does is create your <code>package.json</code> and settings can be easily changed at any time.</p>

<p>The <code>-g</code> means install globally, and the <code>--save-dev</code> will save the packages as development dependancies within the <code>package.json</code>. Have a look, you&rsquo;ll see what I mean.</p>

<p><a href="https://github.com/phonegap/ios-deploy">ios-deploy</a> is neat if you&rsquo;re on a Mac and want to deploy from script or command line to iOS.</p>

<p>The last line scaffolds a basic Cordova project.</p>

<p>Paste in the following to your newly created <code>gulpfile.js</code>, but don&rsquo;t run anything yet!</p>

<pre><code class="js">var gulp = require('gulp')
    del = require('del'),
    cordova = require('cordova-lib').cordova.raw;

var APP_PATH = './app',
    CORDOVA_PATH = './cordova/www';

gulp.task('del-cordova', function(cb) {
    del([ CORDOVA_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('compile', [ 'del-cordova' ], function(cb) {
    return gulp.src([ APP_PATH + '/**/*' ])
        .pipe(gulp.dest(CORDOVA_PATH));
});

gulp.task('build', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .build()
        .then(function() {
            process.chdir('../');
            cb();
        });
});

gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<p>If you ran anything at the point, you&rsquo;d replace the default Cordova <code>www</code> directory with that stark emptiness of your nonexistent <code>app</code> directory. Remedy that with the following, which moves the contents of <code>cordova/www</code> to <code>app</code>.</p>

<pre><code class="bash">mv ./cordova/www ./app
</code></pre>

<p>You now have the almost complete example. If you type in <code>gulp compile</code>, <code>cordova/www</code> will be recreated with the contents of <code>app</code>. Nothing else is going on here at the moment, but think of the possibilities.</p>

<p>We haven&rsquo;t quite finished yet. Type in the following, to add iOS and/or Android as platforms to your new project.</p>

<pre><code class="bash">cd cordova
cordova platform add ios
cd ../
</code></pre>

<p>While you&rsquo;re in the <code>cordova</code> directory, you could have also run <code>cordova build</code> or <code>cordova emulate ios</code>, but that&rsquo;s for losers.</p>

<p>Within in the project root, run either of these bad boys:</p>

<pre><code class="bash">gulp build
gulp emulate
</code></pre>

<p>That&rsquo;s right, one command to rule them all. <code>gulp emulate</code> transpiles the code, moves it to <code>cordova/www</code> then kicks off the Cordova <code>build</code> and <code>emulate</code> commands.</p>

<p>&ldquo;But how does this sorcery work?&rdquo; I hear you cry. Cordova developers will mostly recognise Cordova&rsquo;s <a href="https://www.npmjs.com/">NPM</a> package as a command line tool, but as such a package, we should also be able to require it within a Node script (or in this case, Gulp). The reference here, <code>cordova = require('cordova-lib').cordova.raw</code>, provides access to the Cordova&rsquo;s underlying API, exposing stuff like <code>build</code> and <code>emulate</code>.</p>

<p>It&rsquo;s not all unicorns mind; the API has auto-detection routine in place that works out the project&rsquo;s root directory. This only works however, if you&rsquo;re within Cordova&rsquo;s project structure. I&rsquo;m positive this can be overcome by &lsquo;cleaner&rsquo; methods of API abstraction, but for the moment I&rsquo;ve circumvented the issue by introducing two calls to <code>process.chdir</code>. <code>chdir</code> changes the working directory of running script. The second call resets the directory, for the purposes of possible task chaining.</p>

<p>See here:</p>

<pre><code class="js">gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<ol>
<li>We change the directory.</li>
<li>We call <code>run</code>. <code>emulate</code> is an alias for <code>run</code>.</li>
<li>When the <code>run</code> process completes, the directory is reset.</li>
</ol>


<p>So there you have it, in a single Gulp command you can, transpile, populate, build and emulate. For me, this little nugget has sped up my workflow, and has made the build task more approachable to other developers working on the project.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[In the Name of Gulp]]></title>
    <link href="http://rich.k3r.me/blog/2015/03/23/in-the-name-of-gulp/"/>
    <updated>2015-03-23T22:41:47+00:00</updated>
    <id>http://rich.k3r.me/blog/2015/03/23/in-the-name-of-gulp</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> Use Gulp 4 if you care about task management. If you can&rsquo;t use Gulp 4, use Gulp 3 with &lsquo;runSequence&rsquo;. Also, I need to start reading documentation more and assuming less.</em></p>

<p><em><strong>NOTE:</strong> You see the code over at <a href="https://github.com/kim3er/gulp-4-demo">Github</a>.</em></p>

<p>The release of Gulp 4 is right around the corner, but you can already use it on the <a href="https://github.com/gulpjs/gulp/tree/4.0">4.0 branch</a>. Here is why you should.</p>

<!-- more -->


<h2>Feelings of inadequacy</h2>

<p>When <a href="http://gruntjs.com/">Grunt</a> gained popularity, I was excited by the premise, but underwhelmed by the execution. I feel this is more due to a deficiency on my part, rather than an actual problem with Grunt, given the <a href="http://gruntjs.com/development-team">team</a> behind it. Just looking at the <a href="http://gruntjs.com/getting-started">Getting Started</a> page causes static to course through my brain. #brains</p>

<p>This feeling of inadequacy stayed with me until I found <a href="https://github.com/gulpjs/gulp">Gulp</a>. Gulp&rsquo;s barrier to entry seems a lot lower than Grunt&rsquo;s, it&rsquo;s really a tool you can just run with. Now I feel great about myself, now that I&rsquo;ve found &lsquo;my people&rsquo;. Amen brothers and sisters, this is the house of Gulp.</p>

<h2>Asynchronous shrubs</h2>

<p>It&rsquo;s not all roses in the garden of Gulp 3 though, well maybe it is, but those roses have thorns. And those thorns all bare the words &lsquo;async callbacks&rsquo;. If you&rsquo;ve ever considered Gulp tasks to be modular, building blocks of larger tasks, then you&rsquo;ve probably faced the same disappointment that I have, that they&rsquo;re not.</p>

<p>Take this simple gulpfile:</p>

<pre><code class="js">var gulp = require('gulp')
    sass = require('gulp-sass'),
    babel = require('gulp-babel'),
    del = require('del');

var DEST = './dest',
    SRC = './src';

gulp.task('clean', function(cb) {
    del(DEST, cb);
});

gulp.task('stylesheets', function() {
    return gulp.src(SRC + '/app.scss')
        .pipe(sass())
        .pipe(gulp.dest(DEST));
});

gulp.task('javascripts', function() {
    return gulp.src(SRC + '/app.js')
        .pipe(babel({ blacklist: [ 'useStrict' ] }))
        .pipe(gulp.dest(DEST));
});

gulp.task('html', function() {
    return gulp.src(SRC + '/app.html')
        .pipe(gulp.dest(DEST));
});

gulp.task('default', [ 'clean', 'stylesheets', 'javascripts', 'html' ], function() {

});
</code></pre>

<p>The script above takes the contents of <code>src</code> and sticks it in <code>dest</code>. There is a problem with the script above, that becomes apparent when you check the output:</p>

<pre><code class="bash">[22:02:10] Starting 'clean'...
[22:02:10] Starting 'stylesheets'...
[22:02:10] Starting 'javascripts'...
[22:02:10] Starting 'html'...
[22:02:10] Finished 'clean' after 23 ms
[22:02:10] Finished 'javascripts' after 48 ms
[22:02:10] Finished 'html' after 45 ms
[22:02:10] Finished 'stylesheets' after 55 ms
[22:02:10] Starting 'default'...
[22:02:10] Finished 'default' after 12 μs
</code></pre>

<p>Look at the fifth entry, it&rsquo;s the <code>clean</code> task finishing after 23 milliseconds, after all the other tasks have already started. So the clean script is still deleting stuff after the other tasks have started moving their stuff across.</p>

<h2>Something funny about iteration</h2>

<pre><code class="js">gulp.task('default', [ 'clean' ], function() {
    [ 'stylesheets', 'javascripts', 'html' ].forEach(function(taskName) {
        gulp.start(taskName);
    });
});
</code></pre>

<p>With the <code>default</code> task above, the <code>clean</code> task will complete before any other task starts; no more conflict. Thing is though, looking at the output, the <code>default</code> task is the first to finish after <code>clean</code>. Because Gulp tasks are asynchronous (non blocking), the <code>default</code> task has no reason to hang around waiting for all the tasks in the <code>forEach</code> to complete; the code is only interested in starting each task. This isn&rsquo;t a big deal in our example, but what if you then needed to add a third step?</p>

<pre><code class="js">gulp.task('build', [ 'clean' ], function(cb) {
    [ 'stylesheets', 'javascripts', 'html' ].forEach(function(taskName) {
        gulp.start(taskName);
    });
    cb();
});

gulp.task('deploy', [ 'build' ], function() {
    console.log('deploy!');
});

gulp.task('default', [ 'deploy' ], function() {

});
</code></pre>

<p>Check out the output:</p>

<pre><code class="bash">[22:28:20] Starting 'clean'...
[22:28:20] Finished 'clean' after 8.59 ms
[22:28:20] Starting 'build'...
[22:28:20] Starting 'stylesheets'...
[22:28:20] Starting 'javascripts'...
[22:28:20] Starting 'html'...
[22:28:20] Finished 'build' after 10 ms
[22:28:20] Starting 'deploy'...
deploy!
[22:28:20] Finished 'deploy' after 59 μs
[22:28:20] Starting 'default'...
[22:28:20] Finished 'default' after 2.89 μs
[22:28:20] Finished 'html' after 42 ms
[22:28:20] Finished 'javascripts' after 45 ms
[22:28:20] Finished 'stylesheets' after 52 ms
</code></pre>

<p>The <code>deploy</code> task finishes before the <code>build</code> tasks have completed, which is obviously not ideal!</p>

<h2>My &lsquo;go to&rsquo; for async code (given up on the &lsquo;humor&rsquo;)</h2>

<p>I had expected to find that the <code>start</code> function would support a callback or even an event emitter. That being the case, we could use something like <a href="https://github.com/caolan/async">async</a> (a neat package for dealing with asynchronous code) to do something like:</p>

<pre><code class="js">    async
        .eachSeries(
            [ 'stylesheets', 'javascripts', 'html' ],
            function(taskName, callback) {
                gulp.start(taskName, function() { callback(); });
                // or
                // gulp.start(taskName).on('end', callback);
            },
            function(err) {
                cb()
            }
        );
</code></pre>

<p>But alas, not. The <code>start</code> function is fire and forget. In the example above, crazy stuff happens in the output:</p>

<pre><code class="bash">[20:34:15] Starting 'clean'...
[20:34:15] Finished 'clean' after 8.25 ms
[20:34:15] Starting 'build'...
[20:34:15] Starting 'stylesheets'...
[20:34:15] Finished 'stylesheets' after 25 ms
</code></pre>

<h2>&lsquo;runSequence&rsquo;, a beautiful stopgap</h2>

<p>What you need, is an unassuming, wicked little plugin called <a href="https://www.npmjs.com/package/run-sequence">run-sequence</a>. Using &lsquo;run-sequence&rsquo;, you can do something like:</p>

<pre><code class="js">gulp.task('build', [ 'clean' ], function(cb) {
    runSequence(
        [ 'stylesheets', 'javascripts', 'html' ],
        cb
    );
});
</code></pre>

<p>You can see from the output that we get exactly what we want:</p>

<pre><code class="bash">[20:41:34] Starting 'clean'...
[20:41:34] Finished 'clean' after 8.18 ms
[20:41:34] Starting 'build'...
[20:41:34] Starting 'stylesheets'...
[20:41:34] Starting 'javascripts'...
[20:41:34] Starting 'html'...
[20:41:34] Finished 'html' after 44 ms
[20:41:34] Finished 'stylesheets' after 54 ms
[20:41:34] Finished 'javascripts' after 49 ms
[20:41:34] Finished 'build' after 56 ms
[20:41:34] Starting 'deploy'...
deploy!
[20:41:34] Finished 'deploy' after 81 μs
[20:41:34] Starting 'default'...
[20:41:34] Finished 'default' after 3.88 μs
</code></pre>

<p>&lsquo;run-sequence&rsquo; is cool, but there is a better way.</p>

<h2>The point of the post</h2>

<p>Gulp 4 uses <a href="https://github.com/phated/undertaker">undertaker</a> for task management. This is significant because &lsquo;undertaker&rsquo; supports the chaining of series and parallel tasks. In order to make use of this functionality, you need to install the prerelease version of Gulp, which is easily done by following this <a href="http://demisx.github.io/gulp4/2015/01/15/install-gulp4.html">guide</a>.</p>

<p>You can see examples of series and parallel functionality, <a href="https://github.com/gulpjs/gulp/blob/4.0/docs/recipes/running-tasks-in-series.md">here</a>, but check this out:</p>

<pre><code class="js">gulp.task('build', gulp.series('clean', 'stylesheets', 'javascripts', 'html'));

gulp.task('deploy', gulp.series('build', function(cb) {
    console.log('deploy!');
    cb();
}));

gulp.task('default', gulp.series('deploy'));
</code></pre>

<p>The difference here is that the dependancies array and callback have been replaced with chain-able <code>series</code> functions. You can see from the output below that, while the <code>deploy</code> task appears to start too early, the <code>console.log</code> demonstrates that the meat and veg of the task runs when it needs to.</p>

<pre><code class="bash">[21:39:29] Starting 'default'...
[21:39:29] Starting 'deploy'...
[21:39:29] Starting 'build'...
[21:39:29] Starting 'clean'...
[21:39:29] Finished 'clean' after 8.95 ms
[21:39:29] Starting 'stylesheets'...
[21:39:29] Finished 'stylesheets' after 17 ms
[21:39:29] Starting 'javascripts'...
[21:39:29] Finished 'javascripts' after 32 ms
[21:39:29] Starting 'html'...
[21:39:29] Finished 'html' after 2.98 ms
[21:39:29] Finished 'build' after 62 ms
[21:39:29] Starting '&lt;anonymous&gt;'...
deploy!
[21:39:29] Finished '&lt;anonymous&gt;' after 222 μs
[21:39:29] Finished 'deploy' after 63 ms
[21:39:29] Finished 'default' after 65 ms
</code></pre>

<p>To sum up. Gulp 4 is a huge step forward in terms of task management. I&rsquo;ve had no problems with v4 so far, but if you need to hang with v3 for a little while longer, &lsquo;run-sequence&rsquo; is a good option.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[localForage for Cross-platform Storage]]></title>
    <link href="http://rich.k3r.me/blog/2015/02/28/localforage-for-cross-platform-storage/"/>
    <updated>2015-02-28T09:30:05+00:00</updated>
    <id>http://rich.k3r.me/blog/2015/02/28/localforage-for-cross-platform-storage</id>
    <content type="html"><![CDATA[<p><em>TL;DR: You should be using <a href="https://mozilla.github.io/localForage/">localForage</a> for all your web based local storage needs. It&rsquo;s wonderful.</em></p>

<p>Storage in general is a bit of a tricky one in hybrid development. There are three main types of storage (excluding bespoke implementations and filesystem) you potentially have access to in a web based development:</p>

<!-- more -->


<h2>localStorage</h2>

<p>Until recently, my &ldquo;go to guy&rdquo; for app storage. localStorage is really easy to use key-value storage, that is at the time of writing, the only consistent cross-platform storage mechanism. The problem with localStorage though, is that you typically only get access to 5MB. This has always been sufficient for my needs in the past, but you can&rsquo;t help thinking that&rsquo;s a scalability problem waiting to happen. The limit speaks to the intended use for this sort of storage; if you&rsquo;ve a lot of data, look somewhere else.</p>

<pre><code class="javascript">localStorage.setItem('key', 'value');
</code></pre>

<p><a href="http://caniuse.com/#feat=namevalue-storage">Compatibility</a></p>

<h2>WebSQL</h2>

<p>WebSQL is an implementation of Sqlite, which is great, because I love Sqlite. What is not so great is that there is no support for IE/Firefox, and non seemingly on the horizon. I suspect it&rsquo;s due to the lack of involvement from two major vendors, that <a href="http://en.wikipedia.org/wiki/Web_SQL_Database">W3C ceased working on the specification in November 2010</a>. No more to be said.</p>

<pre><code class="javascript">
var database = openDatabase('testDB', '1.0', 'Test Database', 1024 * 1024);
database.transaction(function (transaction) {
   transaction.executeSql('CREATE TABLE IF NOT EXISTS entries (id INTEGER PRIMARY KEY, value VARCHAR)');
   transaction.executeSql('INSERT INTO entries (value) VALUES ("value")');
});
</code></pre>

<p><a href="http://caniuse.com/#feat=sql-storage">Compatibility</a></p>

<h2>IndexedDB</h2>

<p>IndexedDB has gained <a href="http://www.girliemac.com/blog/2014/07/03/indexeddb/">greater platform support of late</a>. Even so, with support having only just been implemented in iOS &amp; Android, legacy support is an issue. The Blob support is really interesting. But actually, beyond what I&rsquo;ve read, I don&rsquo;t know too much about IndexedDB, I&rsquo;ve never really used it.</p>

<p><em>NOTE: I went hunting around for an example for IndexedDB, the best article I came across was <a href="http://code.tutsplus.com/tutorials/working-with-indexeddb--net-34673">this one</a>.  Wow, is IndexedDB long winded or what?!</em></p>

<p><a href="http://caniuse.com/#feat=indexeddb">Compatibility</a></p>

<p>So, which storage mechanism am I using? Well, I&rsquo;m probably using IndexedDB in most cases. Ehh? I recently had call to convert a Cordova app to a Chrome app. The app in question was using localStorage. Trick is, Chrome apps don&rsquo;t support standard localStorage. They have their own version (called <a href="https://developer.chrome.com/apps/storage">chrome.storage</a>) that is very similar to localStorage, but is asynchronous nature. I didn&rsquo;t really want to rewrite the whole data layer specifically to work with Chrome app, but I found the idea of making it  asynchronous appealing . Maybe it was time to break my reliance on localStorage.</p>

<p>I found <a href="https://mozilla.github.io/localForage/">localForage</a>, a Mozilla library that wraps localStorage, WebSQL and IndexedDB into asynchronous localStorage API. Perfect! The library basically uses whatever is available; You can even set or of precedence and write your own adapters (I&rsquo;m thinking <a href="https://developer.chrome.com/apps/storage#property-sync">chrome.storage.sync</a>).</p>

<p>Below is a fragment of the code I&rsquo;ve converted to use localForage. The JavaScript is written using ES6.</p>

<pre><code class="javascript">class InternalStorage {

    constructor(key) {
        this._storage = localStorage;
    }

    _serialize(data) {
        return JSON.stringify(data);
    }

    _deserialize(value) {
        return JSON.parse(value);
    }

    _getIndexKey() {
        return this._key + '-index';
    }

    getIndex() {
        var value = this._storage.getItem(this._getIndexKey());

        if (value) {
            return this._deserialize(value);
        }
        else {
            return [];
        }
    }

    setIndex(array=[]) {
        var obj = this._serialize(array);
        return this._storage.setItem(this._getIndexKey(), obj);
    }

}
</code></pre>

<p>Here is the converted code, using localForage:</p>

<pre><code class="javascript">class InternalStorage {

    constructor(key) {
        this._storage = localforage;
    }

    _serialize(data) {
        return data;
    }

    _deserialize(value) {
        return value;
    }

    _getIndexKey() {
        return this._key + '-index';
    }

    getIndex() {
        var self = this;

        return new Promise(function(resolve, reject) {
            self._storage.getItem(self._getIndexKey())
                .then((value) =&gt; { resolve(self._deserialize(value)); });
        });
    }

    setIndex(array=[]) {
        var obj = this._serialize(array);
        return this._storage.setItem(this._getIndexKey(), obj);
    }

}
</code></pre>

<p>The things to notice with the transition to localForage are:</p>

<ul>
<li>No requirement to serialise/deserialise, as localForage deals with this.</li>
<li>localForage returns an ES6 Promise, so, so does <code>setIndex</code>.</li>
<li>I&rsquo;ve wrapped the logic for <code>getIndex</code> in a Promise, so I can keep my <code>_serialize</code> method in place. Well, you never know.</li>
</ul>


<p>ES6 is a big thing for me at the moment, so the fact that localForage supports ES6 compliant promises, was very appealing. The ability to write additional adapters adds future proofing. My one gripe, which isn&rsquo;t an issue with localForage, is that we don&rsquo;t have a robust solution for relational storage in our web based development at the moment.</p>
]]></content>
  </entry>
  
</feed>
