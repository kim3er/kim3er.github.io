<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Adventures in brine]]></title>
  <link href="http://rich.k3r.me/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://rich.k3r.me/"/>
  <updated>2015-06-16T23:29:45+01:00</updated>
  <id>http://rich.k3r.me/</id>
  <author>
    <name><![CDATA[Richard Kimber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Async/await, Readable Non-blocking Code]]></title>
    <link href="http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code/"/>
    <updated>2015-06-16T23:06:49+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> Shit just got streamlined. More specifically, promises start looking cleaner when you spray them with &lsquo;Callbacks Begone&rsquo;.</em></p>

<p>In this post I&rsquo;m going to give you a quick demo of how easy it is to incorporate ES7&rsquo;s proposed <a href="https://github.com/lukehoban/ecmascript-asyncawait">Async/Await</a> functionality into your existing ES6 code. To build the code, I&rsquo;m using <a href="https://babeljs.io/">Babel</a> with &lsquo;es7.asyncFunctions&rsquo; enabled. You can read about my <a href="https://github.com/gulpjs/gulp">Gulp</a> setup <a href="/blog/2015/03/23/in-the-name-of-gulp/">here</a>.</p>

<!-- More -->


<p>Consider the code below:</p>

<pre><code class="js">function asyncFuncA() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncA'); }, 2000);
  });
}

function asyncFuncB() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncB'); }, 1000);
  });
}

class AsyncController {

  render(template, data) {
    return new Promise(function(resolve, reject) {
      // Do render stuff
      resolve({ t: template, d: data });
    });
  }

  asyncAction(route) {
    return asyncFuncA()
      .then(function(a) {
        return asyncFuncB()
          .then(b =&gt; { return [ a, b ]; });
      })
      .then(data =&gt; { return this.render('route', data); });
  }

}

let c = new AsyncController();

c.asyncAction()
  .then((obj) =&gt; { console.log(`${obj.d[0]} + ${obj.d[1]}`); });
</code></pre>

<p>We&rsquo;re looking at a Controller class with a couple of actions. The <code>asyncAction</code> function of <code>AsyncController</code> is what we&rsquo;re interested in. The action resolves two promises, one after the other, before calling <code>render</code> with the results of the two promises. In a <a href="/blog/2015/04/29/empty-promises-dos-and-donts-of-es6-promises/">previous article</a>, we already removed a couple of callbacks with <code>Promise.all</code>.</p>

<pre><code class="js"> asyncAction(route) {
    return Promise.all([ asyncFuncA(), asyncFuncB() ])
      .then(data =&gt; { return this.render('route', data); });
  }
</code></pre>

<p>A lot cleaner, but we can do better. <code>async</code> and <code>await</code> are keywords that, when used together, allow you to write asynchronous code without callbacks. <code>async</code> creates a container, within which you can execute promises (prefixed with <code>await</code>) that halt the current scope, until the promises have resolved. The resulting values of said promises are returned in the same way would expect a synchronous function to behave.</p>

<p>What is important, is that this only happens within the <code>async</code> container, which is itself becomes a promise. In the following example <code>p</code> and <code>a</code> are roughly equivalent.</p>

<pre><code class="js">function p() {
  return Promise.resolve('hello world');
}

async function a() {
  return 'hello world';
}

p().then((r) =&gt; { console.log(r); });
a().then((r) =&gt; { console.log(r); });
</code></pre>

<p>What I think is particularly neat, is that class functions can also be decorated with <code>async</code>. So we can use this &lsquo;syntastical&rsquo; sugar on our original example to create:</p>

<pre><code class="js">  async asyncAction(route) {
    return this.render(route, [ await asyncFuncA(), await asyncFuncB() ]);
  }
</code></pre>

<p>The code above is equivalent to the <code>asyncAction</code> functions of the previous examples. I mean, pure, wow factor. It&rsquo;s so awesome, I&rsquo;m giddy. Deep breaths, carry on. <code>asyncFuncA</code> and <code>asyncFuncB</code> are both functions that return promises. These promises both return simple strings, after different timeout periods, during which time the <code>asyncAction</code> function&rsquo;s execution is halted. After the promises has resolved, the final value is returned to current scope and execution continues, as if the <code>await</code> functions were synchronous.</p>

<p>This new functionality has taken promises to a whole new level for me. The <code>async</code> function by itself, removes the need for repetitive <code>Promise</code> declarations. Combined with <code>await</code>, we get asynchronous code that is as easy to read as synchronous code. And no callbacks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Routing With JavaScript Decorators]]></title>
    <link href="http://rich.k3r.me/blog/2015/05/20/simple-routing-with-javascript-decorators/"/>
    <updated>2015-05-20T22:30:57+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/05/20/simple-routing-with-javascript-decorators</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> I&rsquo;ve used decorators to generate a bunch of routes from a class.</em></p>

<p>I can&rsquo;t decide whether this is a legitimate use for decorators, but I knew from the moment I saw this crazy syntax that this was want I wanted to achieve.</p>

<!-- More -->


<h2>What&rsquo;s what?</h2>

<p>In a lot of my app projects, I chuck my actions into a series of classes which extend a simple class called <code>Controller</code>. My old code for <code>Controller</code> is below and as you can see, it exposes an empty array of actions.</p>

<pre><code class="javascript">class Controller {

    actions() {
        return [];
    }

    constructor(app = {}) {
        this.app = app;
    }

}
</code></pre>

<p>The idea is that in the extended class, you add &lsquo;action&rsquo; functions, that you then list in the overridden array. See the example <code>NotesController</code> below.</p>

<pre><code class="javascript">class NotesController extends Controller {

    actions() {
        return [
            { match: 'note', action: 'show' },
            { match: 'notes/create', action: 'create' },
            { match: 'notes/new', action: 'new' }
        ];
    }

    show(id) {

    }

    create(params, data, $form) {

    }

    new() {

    }

    doSomethingUseful() {

    }

}
</code></pre>

<p><code>NotesController</code> now advertises which routes it&rsquo;s setup to listen to. Any function not listed n the array is ignored and assumed to be a helper method of some kind. This has alway felt a bit clunky, specifically I didn&rsquo;t like:</p>

<ol>
<li>Overriding a function, whose sole purpose to create and return a new array each time it&rsquo;s called. During the application lifecycle it&rsquo;s typically only called once, but that&rsquo;s not the point. I could have used class properties, but it&rsquo;s still quite a new feature for Babel. I could have used <a href="http://www.typescriptlang.org/">TypeScript</a> I guess, but <a href="http://www.sublimetext.com/3">Sublime Text</a> tooling for TS has not been a positive experience and I&rsquo;m not ready to switch to <a href="https://code.visualstudio.com/">Visual Studio Code</a>, yet.</li>
<li>The repetition of writing a function, then list it in an array. #boring.</li>
</ol>


<h2>So, what&rsquo;s what now?</h2>

<p>Glad you asked. I&rsquo;ve basically ripped off the <code>autobind</code> example from the <a href="http://babeljs.io/blog/2015/03/31/5.0.0/#stage-1:-decorators">Babel 5.0.0 blog post</a> and created  a new decorator called <code>route</code>. Checkout the code for <code>route</code> below.</p>

<pre><code class="javascript">function route(route) {
    return function(target, key, descriptor) {
        var fn = descriptor.value;

        delete descriptor.value;
        delete descriptor.writable;

        if (!route) {
            route = key;
        }

        descriptor.get = function() {
            var bound = fn.bind(this, route);

            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                value: bound
            });

            return bound;
        };

        if (!target.routes) {
            target.routes = [];
        }

        target.routes.push({ match: route, action: key });

    };
}
</code></pre>

<p>The differences between this decorator and the <code>autobind</code> example are:</p>

<ol>
<li><code>route</code> takes an optional parameter (also called <code>route</code>), that allows you to specify the route to be matched. Optional, in that if missed out, the decorator assumes the name of the action, is also the route.</li>
<li>An array of the routes is managed on the instance of the controller, so the array is an instance property now.</li>
<li>I&rsquo;m passing the <code>route</code> param to the function, as it&rsquo;s often useful to know the route in the function.</li>
</ol>


<p>Let&rsquo;s see the new code:</p>

<pre><code class="javascript">// Controller Class
class Controller {

    constructor(app = {}) {
        this.app = app;

        // In case no routes are specified
        if (!this.routes) {
            this.routes = [];
        }
    }

}

// NotesController Class
class NotesController extends Controller {

    @route('note')
    show(id) {

    }

    @route('notes/create')
    create(params, data, $form) {

    }

    @route()
    new() {

    }

    doSomethingUseful() {

    }

}
</code></pre>

<p>You can see, no more <code>actions</code> function, no more verbose listing of the functions. I&rsquo;ve intentionally left out the value of the <code>new</code> route, to demonstrate how the &lsquo;implied&rsquo; routing works. If you run the code above in the Babel <a href="http://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=function%20route(route)%20%7B%0A%09return%20function(target%2C%20key%2C%20descriptor)%20%7B%0A%09%09var%20fn%20%3D%20descriptor.value%3B%0A%0A%09%09delete%20descriptor.value%3B%0A%09%09delete%20descriptor.writable%3B%0A%0A%09%09if%20(!route)%20%7B%0A%09%09%09route%20%3D%20key%3B%0A%09%09%7D%0A%0A%09%09descriptor.get%20%3D%20function()%20%7B%0A%09%09%09var%20bound%20%3D%20fn.bind(this%2C%20route)%3B%0A%0A%09%09%09Object.defineProperty(this%2C%20key%2C%20%7B%0A%09%09%09%09configurable%3A%20true%2C%0A%09%09%09%09writable%3A%20true%2C%0A%09%09%09%09value%3A%20bound%0A%09%09%09%7D)%3B%0A%0A%09%09%09return%20bound%3B%0A%09%09%7D%3B%0A%0A%09%09if%20(!target.routes)%20%7B%0A%09%09%09target.routes%20%3D%20%5B%5D%3B%0A%09%09%7D%0A%0A%09%09target.routes.push(%7B%20match%3A%20route%2C%20action%3A%20key%20%7D)%3B%0A%0A%09%7D%3B%0A%7D%0A%0Aclass%20Controller%20%7B%0A%0A%09constructor(app%20%3D%20%7B%7D)%20%7B%0A%09%09this.app%20%3D%20app%3B%0A%0A%09%09if%20(!this.routes)%20%7B%0A%09%09%09this.routes%20%3D%20%5B%5D%3B%0A%09%09%7D%0A%09%7D%0A%0A%7D%0A%0A%2F%2F%20NotesController%20Class%0Aclass%20NotesController%20extends%20Controller%20%7B%0A%0A%09%40route('note')%0A%09show(id)%20%7B%0A%0A%09%7D%0A%0A%09%40route('notes%2Fcreate')%0A%09create(params%2C%20data%2C%20%24form)%20%7B%0A%0A%09%7D%0A%0A%09%40route()%0A%09new()%20%7B%0A%0A%09%7D%0A%09%0A%09doSomethingUseful()%20%7B%0A%09%0A%09%7D%0A%0A%7D%0A%0Aconsole.log(new%20NotesController().routes)">REPL</a>, you should get the output below:</p>

<pre><code class="javascript">[
    {"match":"note","action":"show"},
    {"match":"notes/create","action":"create"},
    {"match":"new","action":"new"}
]
</code></pre>

<p>With the exception of <code>new</code>, the array is identical to that of the first example. That be some nice ass syntactic sugar. The future rocks. Peace out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Empty Promises: Dos and Don'ts of ES6 Promises]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/29/empty-promises-dos-and-donts-of-es6-promises/"/>
    <updated>2015-04-29T22:10:03+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/29/empty-promises-dos-and-donts-of-es6-promises</id>
    <content type="html"><![CDATA[<p><em><strong>UPDATE 14/06/15:</strong> Realised the existence of <code>Promise.resolve</code>, added info on <code>Promise.all</code>.</em></p>

<p>There is so much I love about the functionality and syntax coming through under the banner of ES6. One such piece of functionality, is the &lsquo;Promise&rsquo;. Promises are not something that needs to be transpiled, as of writing, <a href="http://caniuse.com/#feat=promises">all but IE and Opera Mini have support</a> out of the box. The stragglers can be polyfilled <a href="https://github.com/jakearchibald/es6-promise">quite</a> <a href="https://github.com/taylorhakes/promise-polyfill">easily</a>.</p>

<p>What follows, are three tips for using promises more effectively.</p>

<!-- More -->


<h2>Chain, don&rsquo;t nest</h2>

<p>When I first started playing with promises, I found myself nesting code blocks more than I would have liked. Code like:</p>

<pre><code class="js">class Example {

    saveData(data) {
        return new Promise(function(resolve, reject) {
            // Save Data
            resolve(data);
        });
    }

    getFromWeb(id) {
        return new Promise(function(resolve, reject) {
            // Get from web
            resolve(data);
        });
    }

    display(id) {
        let self = this;
        return new Promise(function(resolve, reject) {
            self.getFromWeb(id)
                .then(function(data) {
                    self.saveData(data)
                        .then(function(data) {
                            // Display somewhere
                            resolve();
                        });
                });
        });
    }
}

new Example().display(1);
</code></pre>

<p>Not very readable and not making great use of screen real estate, when you can actually do:</p>

<pre><code class="js">display(id) {
    let self = this;
    return self.getFromWeb(id)
        .then(function(data) {
            return self.saveData(data);
        })
        .then(function(data) {
            // Display somewhere
            return data;
        });
}
</code></pre>

<p>The <code>display</code> function is doing exactly the same, but now the functionality is chained. The second <code>then</code> function deals with the display logic, before returning the data param, enabling the <code>display</code> function to be chained itself:</p>

<pre><code class="js">new Example().display(1).then((data) =&gt; { /* Work on data */ console.log('async finished'); });
</code></pre>

<h2>Empty Promises</h2>

<p>I&rsquo;m one of those people who has never read a VCR manual. I pick up and do, realising only years later, that I didn&rsquo;t need to rush home every time I wanted to record something, because the VCR had a timer. I once wrote a really handy little function in SQL called <code>VALUENULL</code>, for dealing with NULL values. I can&rsquo;t believe that sort of functionality wasn&rsquo;t built in, oh wait, <a href="https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=isnull%20sql">ISNULL</a>.</p>

<p>Well, I find myself in that place again. After triumphing that I&rsquo;d come up with such a simple way to provide consistent <code>Promise</code> returning functions with <code>Util.emptyPromise</code> (see below), then worring that such a thing might be considered bad practice.</p>

<pre><code class="js">class Util {

    static emptyPromise(val = null) {
        return new Promise((resolve) =&gt; { resolve(val); });
    }

}
</code></pre>

<p>You see, the point of the function is to wrap a value (or no value) around a prefab <code>Promise</code> that always resolves. You would do this if you were creating a non-blocking/asynchronous API on top of synchronous code. Or if you envisaged blocking code becoming asynchronous in the future and wanted to ensure that the public API didn&rsquo;t feel the affect of such massive breaking changes.</p>

<p>A prime example of this, is when I recently wrote a data layer based on <code>localstorage</code> (which is synchronous), then decided that  <code>localstorage</code> wasn&rsquo;t cutting the mustard, so replaced with <a href="http://mozilla.github.io/localForage/">localForage</a> (which is <code>Promise</code> based). That weekend is one I won&rsquo;t forget in a hurry.</p>

<p>My point is, <code>Util.emptyPromise</code> is a less elegant equivalent to the already existing <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">Promise.resolve</a>. I&rsquo;ll leave this section with the original pun, because it still makes me chuckle.</p>

<p>The function is poorly named, because it can return a value. I just like the pun. An example of the pun in action:</p>

<pre><code class="js">class Election {

    fullOf() {
        return Util.emptyPromise()
            .then(() =&gt; { return Util.emptyPromise(); });
    }

}
</code></pre>

<h2>Promise.all</h2>

<p>You may want to check up my sleeves at this point, because I&rsquo;m about to make bunnies appear out of thin air.</p>

<p>&lsquo;Callbacks&rsquo; is just something you do if you&rsquo;re writing non-blocking JavaScript. Calllbacks, within callbacks, within callbacks. Callbacks are there so that you can control the flow of some logic, which has a dependancy on asynchronous code (like an Ajax request), that will take you away from the main &lsquo;blocking&rsquo; execution thread.</p>

<p>Promises take these callbacks and makes them look a lot prettier, while also providing a platform for deferring the attachment of callbacks. The following example still fires the <code>console.log</code>, even though the callback is attached after the <code>Promise</code> has already resolved.</p>

<pre><code class="js">var p = Promise.resolve();
p.then(function() { console.log('test'); });
</code></pre>

<p>But there is still room to make our code damn right gorgeous. Consider the following code:</p>

<pre><code class="js">function asyncFuncA() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncA'); }, 2000);
  });
}

function asyncFuncB() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncB'); }, 1000);
  });
}

class AsyncController {

  render(template, data) {
    return new Promise(function(resolve, reject) {
      // Do render stuff
      resolve({ t: template, d: data });
    });
  }

  asyncAction(route) {
    return asyncFuncA()
      .then(function(a) {
        return asyncFuncB()
          .then(b =&gt; { return [ a, b ]; });
      })
      .then(data =&gt; { return this.render('route', data); });
  } 

}

let c = new AsyncController();

c.asyncAction()
  .then((obj) =&gt; { console.log(`${obj.d[0]} + ${obj.d[1]}`); });
</code></pre>

<p>Looking at the <code>asyncAction</code>. <code>asyncFuncA</code> and <code>asyncFuncB</code> are chained by calling <code>asyncFuncB</code> within the callback of <code>asyncFuncA</code>. The call to the <code>render</code> function starts on a separate tree, consuming the response of both asynchronous functions. A rocky sort of waterfall.</p>

<pre><code>asyncAction
    --&gt; asyncFuncA
            --&gt; asyncFuncB
        --&gt; render
</code></pre>

<p>We can achieve the same with the function below. The second asynchronous function no longer has a dependancy on the first, and we only have to call <code>then</code> once.</p>

<pre><code class="js"> asyncAction(route) {
    return Promise.all([ asyncFuncA(), asyncFuncB() ])
      .then(data =&gt; { return this.render('route', data); });
  } 
</code></pre>

<pre><code>asyncAction
    --&gt; asyncFuncA
    --&gt; asyncFuncB
        --&gt; render
</code></pre>

<p>Pretty hot!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Consuming ES6 Modules in NPM Packages]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/12/consuming-es6-modules-in-npm-packages/"/>
    <updated>2015-04-12T14:06:12+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/12/consuming-es6-modules-in-npm-packages</id>
    <content type="html"><![CDATA[<p>I&rsquo;m going to have to start coming up with more interesting title for my posts. My eyes are watering at the thought of &lsquo;Consuming ES6 modules in NPM packages&rsquo;. Maybe something more exciting, like &lsquo;Munching on the nuggets of next gen wonderment&rsquo;. I&rsquo;ll work on it.</p>

<p>In this post I&rsquo;m going to describe how you can make use of <a href="https://babeljs.io/">Babel&rsquo;s</a> support for <a href="https://babeljs.io/docs/learn-es6/#modules">ES6 modules</a>, and how you might consume them as <a href="https://www.npmjs.com/">NPM</a> packages. It&rsquo;s pretty neato stuff and makes for very clean code. Read on!</p>

<!-- more -->


<p><em><strong>TL;DR:</strong> Scroll down to the <a href="http://www.starwars.com/">Star Wars</a> reference for the actual tutorial.</em></p>

<p><em><strong>NOTE:</strong> This tutorial has two <a href="https://github.com/">Github</a> repos, <a href="https://github.com/kim3er/example-es6-module">this one</a> and <a href="https://github.com/kim3er/example-module-consumer">this one</a>.</em></p>

<p>Modules have existed in JS space for a while now. I&rsquo;ve dabbled in the past, because I&rsquo;m a big fan of results, I mean who wouldn&rsquo;t be?</p>

<ul>
<li>Keeps junk out of the global scope</li>
<li>Only load what you need</li>
<li>Inferred order of compilation</li>
</ul>


<p>I&rsquo;m just going to pick up on that last point for a moment. While I dabbled, I never really embraced modules as part of a longer term strategy. My reluctance was due to inherent ugliness of implementation, with anything but Node&rsquo;s <code>require</code> and <code>exports</code> syntax. The ugliness is there to make these great ideas work in the browser.</p>

<p>Using the fantastic <a href="https://jquery.com/">jQuery</a> as an example, stuff like:</p>

<pre><code class="js">    if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }
</code></pre>

<p>and</p>

<pre><code class="js">// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" &amp;&amp; define.amd ) {
    define( "jquery", [], function() {
        return jQuery;
    });
}
</code></pre>

<p>and</p>

<pre><code class="js">// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
    window.jQuery = window.$ = jQuery;
}
</code></pre>

<p>I get why it&rsquo;s all there, and I appreciate the efforts teams like jQuery put into compatibility with all of these different systems. I have benefitted from those efforts on many occasions. I bet it&rsquo;s a pain in the backside to maintain, it&rsquo;s very clever, but also, U-G-L-Y.</p>

<h3>Flashback (wavy lines)</h3>

<p>I was drawn back into the fold, as the result of a recent ES6 based project I&rsquo;ve been working on. I was gorging on the beautiful ES6 class syntax, doing a fine job of controlling compilation through the use of sub folders.</p>

<p>As an example, the classes in directories &lsquo;controller&rsquo; and &lsquo;model&rsquo;, inherit from directory &lsquo;base&rsquo;. Classes in &lsquo;controller&rsquo; can reference classes in &lsquo;model&rsquo;, but not the other way around.</p>

<pre><code class="bash">root
    base            &lt;-- Compile first
    controller      &lt;-- Compile third
    model           &lt;-- Compile second
</code></pre>

<pre><code class="js base/base_class.js">class BaseClass {
    parent()  {
        console.log('something interesting');
    }
}
</code></pre>

<pre><code class="js controller/app_controller.js">class AppController extends BaseClass {
    action()  {
        let user = new UserModel();
        console.log('I\'m an action');
    }
}
</code></pre>

<pre><code class="js model/user_model.js">class UserModel extends BaseClass {
    constructor() {
        this.parent();
        console.log('I\'m a model');
    }
}
</code></pre>

<p>This all worked great, better than great, I was king of the world. Until I needed to create <code>BaseController</code>, that extends <code>BaseClass</code> and is extended by <code>AppController</code>.</p>

<pre><code class="js controller/base_controller.js">class BaseController extends BaseClass {
    defaultAction()  {
        console.log('I\'m a default action');
    }
}
</code></pre>

<pre><code class="js controller/app_controller.js">class AppController extends BaseController {
    action()  {
        this.defaultAction();
    }
}
</code></pre>

<p>Due to the dreaded alphabet, <code>AppController</code> compiles before <code>BaseController</code>. Arrrgh. Why world, would you treat me this way?!</p>

<pre><code class="bash">controller
    app_controller.js       &lt;-- Attempts to compile first, but BaseController doesn't exist yet
    base_controller.js      &lt;-- Waits patiently
</code></pre>

<p>Don&rsquo;t tell anyone, but my initial fix was to:</p>

<pre><code class="bash">controller
    0.base_controller.js    &lt;-- Compiles first
    app_controller.js       &lt;-- Compiles second
</code></pre>

<p>I kidded myself for a while that this was a valid design decision, until maybe my third or forth &lsquo;zero dot&rsquo; file. I needed a better way of controlling the order of compilation; it also felt like those base classes could be reused.</p>

<h2>And so, it begins. Destroy them, destroy them all.</h2>

<p>We&rsquo;re going to create two projects; the <a href="https://github.com/kim3er/example-es6-module">module</a> and the <a href="https://github.com/kim3er/example-module-consumer">consumer</a>.</p>

<h3>The module</h3>

<p>The module package will be written in ES6 JavaScript, but will need to be transpilied to ES5, for compatibility. So the ugliness is still there, just hidden. We&rsquo;ll use <a href="http://gulpjs.com/">Gulp</a> and Babel for the build.</p>

<h4>The setup</h4>

<p>I&rsquo;ve created a directory called &lsquo;blog&rsquo;, in here I&rsquo;m writing the following, in terminal:</p>

<pre><code class="bash">mkdir es6-module
cd es6-module
npm init                        &lt;-- Just enter through the defaults
mkdir src
touch gulpfile.js .gitignore
</code></pre>

<p>Your project should look like:</p>

<pre><code class="bash">es6-module
    src                 &lt;-- This is where we\'re going to put our ES6
    .gitignore          &lt;-- We\'ll need to ignore \'node-modules\', when this goes to GIT
    gulpfile.js         &lt;-- Gulp build file
    package.json        &lt;-- This was created when you typed in \'npm init\'
</code></pre>

<p>Make &lsquo;.gitignore&rsquo; look this:</p>

<pre><code class="text .gitignore">node_modules
</code></pre>

<p>Change the <code>main</code> option in &lsquo;package.json&rsquo; to read &lsquo;./lib/index.js&rsquo;. A &lsquo;lib&rsquo; directory will be created as part of the build process, which will contain our ES5 code.</p>

<pre><code class="json">{
    ....
    "main": "./lib/index.js",
    ....
}
</code></pre>

<p><code>main</code> is the entry point to our package. In a consumer, if you were to <code>require('es6-module')</code>, you&rsquo;ll get the exports from the <code>main</code> file.</p>

<h4>The build script</h4>

<p>We need a build script in our &lsquo;gulpfile.js&rsquo;.</p>

<pre><code class="js gulpfile.js">var gulp = require('gulp'),
    del = require('del'),
    babel = require('gulp-babel');

var SRC_PATH = './src',
    LIB_PATH = './lib';

gulp.task('clear', function(cb) {
    del([ LIB_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('build', [ 'clear' ], function() {
    return gulp.src([ SRC_PATH + '/**/*.js' ])
                .pipe(babel({ blacklist: [ 'useStrict' ] }))
                .pipe(gulp.dest(LIB_PATH));
});

gulp.task('default', function() {
    gulp.start('build');
});
</code></pre>

<p>The script has three dependancies:</p>

<ol>
<li>Gulp - The script runner. Like <a href="http://gruntjs.com/">Grunt</a>, but code first.</li>
<li><a href="https://www.npmjs.com/package/del">Del</a> - A little package for deleting stuff.</li>
<li>Babel - ES6 transpiler. Reinvigorated my already deeply unnatural love of JavaScript. Hallelujah.</li>
</ol>


<p>Install the dependancies like so:</p>

<pre><code class="bash">npm install -g gulp babel
npm install --save-dev gulp del gulp-babel
</code></pre>

<p>I think the <code>clear</code> task is self explanatory, so lets talk about <code>build</code>. Typically in a build script, it&rsquo;s tempting to concatenate, but our package is going to benefit from keeping the code in separate files. By keeping the code in separate files, modular, we&rsquo;ll be implementing JavaScript module benefit #2 &lsquo;Only load what you need&rsquo;.</p>

<p>The code itself is transpiled through Babel, to create the ES6 code in &lsquo;lib&rsquo;. I&rsquo;ve blacklisted &lsquo;useStrict&rsquo;. I do this by default, because <code>"use strict"</code> can stop execution in iOS UIWebViews, specifically when using <a href="http://cordova.apache.org/">Cordova</a>.</p>

<h4>The code</h4>

<p>In the src directory, create the following files:</p>

<pre><code class="bash">src
    clever_class.js &lt;-- An example module
    index.js        &lt;-- Our main file
</code></pre>

<pre><code class="js src/clever_class.js">export class CleverClass {
    constructor() {
        console.log('I\'m a clever class');
    }
}
</code></pre>

<pre><code class="js src/index.js">export * from './clever_class';
</code></pre>

<p><em>I think you can already see how useful our new package is going to be.</em></p>

<p><code>CleverClass</code> is pretty unexceptional, except for the addition of <code>export</code> before the <code>class</code> declaration. <code>export</code> tells Babel that we want to reference <code>CleverClass</code> as module.</p>

<p>The code in &lsquo;index.js&rsquo; is really interesting. We&rsquo;re literally creating an index to all modules in our package, that we want made public. <code>export * from</code> (not <code>import</code>), re-exports <code>CleverClass</code> as part of &lsquo;index.js&rsquo;.</p>

<p>Think about the implications here. You can have twenty different classes in this directory, all extending each other in different and exciting ways. From &lsquo;index.js&rsquo;, you choose which of those classes make it to your public API. <code>CleverClass</code> may inherit from a class called <code>BaseClass</code>, but only <code>CleverClass</code> is accessible, even though <code>CleverClass</code> still benefits from the existence of <code>BaseClass</code>.</p>

<p><em>At this point, you&rsquo;re starting to feel like Skeletor, just before he was robbed of the powers of Grey Skull.</em></p>

<p>Okay, build the mutha:</p>

<pre><code class="bash">gulp build
</code></pre>

<p>Any errors? No, great. You should now have a &lsquo;lib&rsquo; directory that mirrors the structure of &lsquo;src&rsquo;, just with ES5 code, instead of ES6.</p>

<p><em><strong>NOTE:</strong> This feels a bit &lsquo;fly-by the seat of your pants&rsquo; coding. Usually I&rsquo;d have a test suite in the project, to ensure that we&rsquo;re all rocking in the right direction. However, we&rsquo;re about to build a consumer for exactly that, and for the purposes of this tutorial I wanted to keep concerns clean and avoid duplication. You dig?</em></p>

<h3>The consumer</h3>

<p>The purpose of this tutorial is to demonstrate how you can consume ES6 modules, contained within an NPM package. To do this, we need a separate project, from which to consume the package; this is that project.</p>

<h4>The setup</h4>

<p>From the blog directory:</p>

<pre><code class="bash">mkdir module-consumer
cd module-consumer
npm init                        &lt;-- Just enter through the defaults
mkdir app
touch gulpfile.js .gitignore
</code></pre>

<p>Here is our &lsquo;.gitignore&rsquo;:</p>

<pre><code class="text .gitignore">.web
node_modules
</code></pre>

<p>Here is our directory structure:</p>

<pre><code class="bash">module-consumer
    app                 &lt;-- This is where we\'re going to put our test app
    .gitignore          &lt;-- We'll need to ignore \'node-modules\', when this goes to GIT
    gulpfile.js         &lt;-- Gulp build file
    package.json        &lt;-- This was created when you typed in \'npm init\'
</code></pre>

<h4>The build script</h4>

<p>Our test app is going to be a very simple website, so we&rsquo;re going to need a web server, in this case <a href="https://github.com/senchalabs/connect">Connect</a>. Because we&rsquo;re using a website as our testbed, we need to a way to consume the NPM package in a way that the browser understands; for this, we will use <a href="http://browserify.org/">Browserify</a>.</p>

<pre><code class="js gulpfile.js">var gulp = require('gulp'),
    connect = require('gulp-connect'),
    del = require('del'),
    watch = require('gulp-watch'),
    runSequence = require('run-sequence'),
    babelify = require('babelify'),
    browserify = require('browserify'),
    source = require('vinyl-source-stream');

var APP_PATH = './app',
    WEB_PATH = './.web';

gulp.task('clear', function(cb) {
    del([ WEB_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('js', function() {
    return browserify({
                    entries: APP_PATH + '/app.js',
                    debug: true
                })
                .transform(babelify)
                .bundle()
                .pipe(source('app.js'))
                .pipe(gulp.dest(WEB_PATH));
});

gulp.task('index', function() {
    return gulp.src([ APP_PATH + '/index.html' ])
        .pipe(gulp.dest(WEB_PATH));
});

gulp.task('connect', function(cb) {
    connect.server({
        root: WEB_PATH,
        livereload: true
    });

    cb();
});

gulp.task('livereload', function () {
    return gulp.src( WEB_PATH + '/**/*' )
        .pipe(connect.reload());
});

gulp.task('serve', [ 'clear' ], function(cb) {
    runSequence(
        [ 'js', 'index' ],
        'connect',
        function() {            
            watch([ APP_PATH + '/app.js' ], function() { gulp.start('js'); });
            watch([ APP_PATH + '/index.html' ], function() { gulp.start('index'); });
            watch([ WEB_PATH + '/**/*' ], function() { gulp.start('livereload'); });

            cb();
        }
    );
});
</code></pre>

<p>The script has these dependancies:</p>

<ol>
<li>Gulp</li>
<li>Gulp Connect - Our web server.</li>
<li>Del</li>
<li><a href="https://www.npmjs.com/package/gulp-watch">Gulp Watch</a> - Kicks off Gulp tasks, when a file changes.</li>
<li><a href="https://www.npmjs.com/package/run-sequence">Run Sequence</a> - Asynchronous task management. <a href="/blog/2015/03/23/in-the-name-of-gulp/">Read my blog</a>.</li>
<li><a href="https://github.com/babel/babelify">Babelify</a> - Babel transformer for Browserify.</li>
<li>Browserify - Makes Node&rsquo;s <code>require</code> work in the browser.</li>
<li><a href="https://www.npmjs.com/package/vinyl-source-stream">Vinyl Source Stream</a> - Makes Browserify work with Gulp.</li>
</ol>


<p>Install them:</p>

<pre><code class="bash">npm install --save-dev gulp gulp-connect del gulp-watch run-sequence babelify browserify vinyl-source-stream
</code></pre>

<p>Here&rsquo;s a quick rundown of the tasks in this script:</p>

<h5>js</h5>

<p>Transpiles and concatenates the contents of &lsquo;app/app.js&rsquo; (not created yet), using Browserify. Browserify follows every <code>require</code>, creates a virtual tree, then bundles all the code in one file.</p>

<p><em>I mean, wow, just wow.</em></p>

<p>We&rsquo;re not using the <code>require</code> syntax though, so we need Babelify. Babelify transforms/transpiles the ES6 syntax to ES5, for Browserify to understand.</p>

<p>The result of which is outputted to our temporary web directory (&lsquo;.web&rsquo;, which doesn&rsquo;t exist yet).</p>

<h5>index</h5>

<p>Moves &lsquo;app/index.html&rsquo; to &lsquo;.web/index.html&rsquo;. You don&rsquo;t want to be working directly in &lsquo;.web&rsquo;.</p>

<h5>connect</h5>

<p>Uses Connect to start a web server, with <a href="http://livereload.com/">Live Reload</a>.</p>

<h5>livereload</h5>

<p>Reacts to file changes. Live Reload reloads your browser programmatically. It&rsquo;s pure magic.</p>

<h5>serve</h5>

<p>This is what we type into terminal. It&rsquo;s a &lsquo;stitch everything together task&rsquo;. We use Run Sequence to run our two compilation tasks, <code>js</code> and <code>index</code>, before kicking off the web server task <code>connect</code>. Finally, we set off the file watchers, that react accordingly to file changes.</p>

<h4>The code</h4>

<p>I&rsquo;m going to start by boilerplating &lsquo;index.html&rsquo; in the &lsquo;app&rsquo; directory; the sole point of this file is to load &lsquo;app.js&rsquo;.</p>

<pre><code class="html app/index.html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="./app.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Here&rsquo;s &lsquo;app.js&rsquo;.</p>

<pre><code class="js app/app.js">// Example 1: Namespace
import * as es6 from 'es6-module';

new es6.CleverClass();


// Example 2: Choose exports
// import { CleverClass } from 'es6-module';

// new CleverClass();


// Example 3: Target individual files
// import { CleverClass } from 'es6-module/lib/clever_class';

// new CleverClass();
</code></pre>

<p>&lsquo;app.js&rsquo; contains three examples of how can access &lsquo;CleverClass&rsquo; from our first project&hellip; Aww crap, hang on a minute, we&rsquo;ve not actually referenced our &lsquo;es6-module&rsquo; package!</p>

<pre><code class="bash">npm install --save-dev ../es6-module
</code></pre>

<p><em><strong>NOTE:</strong> NPM allows you to install local packages, that&rsquo;s what going on in the code above.</em></p>

<p>What was I saying? Right, three examples. They should all have the same result, but show the flexibility was the ES6 way of doing modules:</p>

<ol>
<li>Namespace - Using <code>as</code>, you can wrap your imports in a namespace. Very tidy.</li>
<li>Be selective - You may only want to use one or two classes, list them in curly brackets!</li>
<li>Don&rsquo;t pull in the whole library - Prepare to have your mind blown. &lsquo;Boom&rsquo;. You can reference individual modules within the package. Don&rsquo;t say a word, it&rsquo;s alright, I know. #shhh</li>
</ol>


<p>Run the server and breath in the sweet, sweet smell of success.</p>

<pre><code class="bash">gulp serve
</code></pre>

<p>I accept the payoff is a little underwhelming. If all is well, when you open you dev tool in a browser, pointed at <a href="http://localhost:8080">http://localhost:8080</a>, you should see:</p>

<pre><code class="text">I'm a clever class
</code></pre>

<h3>The conclusion</h3>

<p>That&rsquo;s not the point. The point is, &ldquo;I&rsquo;m a clever class&rdquo; was written in module in one package, and accessed from a script in another. All the code was written in ES6, and only the files needed, were accessed in the test site.</p>

<p>We&rsquo;ve gained:</p>

<ol>
<li>A modular build.</li>
<li>A reusable library.</li>
<li>Only compile what you use.</li>
<li>Future proofing, with ES6 compatible base code.</li>
</ol>


<p>We. Are. Awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controlling Cordova From Gulp]]></title>
    <link href="http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp/"/>
    <updated>2015-04-02T22:39:27+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/04/02/controlling-cordova-from-gulp</id>
    <content type="html"><![CDATA[<p>It&rsquo;s a story as old as time. Girl meets boy, boy has an annoying two step build process, spread across two directories. Of course I&rsquo;m talking about having an awesome <a href="http://gulpjs.com/">Gulp</a> workflow, with a Cordova project clumsily tacked on the side. Well, no more, now you can integrate <a href="http://cordova.apache.org/">Cordova</a>! into Gulp! Yay!</p>

<!-- more -->


<p><em><strong>NOTE:</strong> You see the code over at <a href="https://github.com/kim3er/cordova-gulp">Github</a>.</em></p>

<p>Let&rsquo;s discuss the problem first. Until recently, Gulp and Cordova were two separate Node based, command line powered worlds to me, with seemingly nothing in common. In the given scenario, I&rsquo;d typically have a two directory structure:</p>

<pre><code>app             &lt;-- Source files for the project
cordova         &lt;-- Cordova root directory
    - www       &lt;-- Cordova app directory
gulpfile.js
</code></pre>

<p>Gulp would take care of transpiling the code in the <code>app</code> directory and transferring the spoils to <code>cordova/www</code>. Cordova is then responsible for building the Cordova project and delivering the app to an emulator.  Something like:</p>

<pre><code class="bash">gulp
cd ./cordova
cordova emulate
cd ../
</code></pre>

<p>Before switching to Gulp, I used to use Middleman for a lot of the transpiling tasks, where I&rsquo;d maintain a number of bash scripts to create the illusion of cohesion. It didn&rsquo;t feel right when I switched to Gulp though. There must be some similarity between these disparate Node based, command line tools. What was I missing?</p>

<p>You know what I realised? That Gulp is based on Node and so is Cordova; so I can probably access Cordova directly from within my Gulp task. It&rsquo;s never going to be that easy, is it?</p>

<p>Well, it&rsquo;ll be a disappointment if it wasn&rsquo;t that easy. So long story short, it almost is. To demonstrate, I&rsquo;m going to cook up a quick project, to demonstrate the integration:</p>

<pre><code class="bash">npm init
touch gulpfile.js
npm install -g cordova gulp ios-deploy
npm install --save-dev gulp cordova-lib del
cordova create ./cordova me.k3r.cordgulp CordovaGulp
</code></pre>

<p>Accept all the defaults on <code>npm install</code>, if you&rsquo;re not sure how to answer. All it does is create your <code>package.json</code> and settings can be easily changed at any time.</p>

<p>The <code>-g</code> means install globally, and the <code>--save-dev</code> will save the packages as development dependancies within the <code>package.json</code>. Have a look, you&rsquo;ll see what I mean.</p>

<p><a href="https://github.com/phonegap/ios-deploy">ios-deploy</a> is neat if you&rsquo;re on a Mac and want to deploy from script or command line to iOS.</p>

<p>The last line scaffolds a basic Cordova project.</p>

<p>Paste in the following to your newly created <code>gulpfile.js</code>, but don&rsquo;t run anything yet!</p>

<pre><code class="js">var gulp = require('gulp')
    del = require('del'),
    cordova = require('cordova-lib').cordova.raw;

var APP_PATH = './app',
    CORDOVA_PATH = './cordova/www';

gulp.task('del-cordova', function(cb) {
    del([ CORDOVA_PATH + '/*' ], function() {
        cb();
    });
});

gulp.task('compile', [ 'del-cordova' ], function(cb) {
    return gulp.src([ APP_PATH + '/**/*' ])
        .pipe(gulp.dest(CORDOVA_PATH));
});

gulp.task('build', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .build()
        .then(function() {
            process.chdir('../');
            cb();
        });
});

gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<p>If you ran anything at the point, you&rsquo;d replace the default Cordova <code>www</code> directory with that stark emptiness of your nonexistent <code>app</code> directory. Remedy that with the following, which moves the contents of <code>cordova/www</code> to <code>app</code>.</p>

<pre><code class="bash">mv ./cordova/www ./app
</code></pre>

<p>You now have the almost complete example. If you type in <code>gulp compile</code>, <code>cordova/www</code> will be recreated with the contents of <code>app</code>. Nothing else is going on here at the moment, but think of the possibilities.</p>

<p>We haven&rsquo;t quite finished yet. Type in the following, to add iOS and/or Android as platforms to your new project.</p>

<pre><code class="bash">cd cordova
cordova platform add ios
cd ../
</code></pre>

<p>While you&rsquo;re in the <code>cordova</code> directory, you could have also run <code>cordova build</code> or <code>cordova emulate ios</code>, but that&rsquo;s for losers.</p>

<p>Within in the project root, run either of these bad boys:</p>

<pre><code class="bash">gulp build
gulp emulate
</code></pre>

<p>That&rsquo;s right, one command to rule them all. <code>gulp emulate</code> transpiles the code, moves it to <code>cordova/www</code> then kicks off the Cordova <code>build</code> and <code>emulate</code> commands.</p>

<p>&ldquo;But how does this sorcery work?&rdquo; I hear you cry. Cordova developers will mostly recognise Cordova&rsquo;s <a href="https://www.npmjs.com/">NPM</a> package as a command line tool, but as such a package, we should also be able to require it within a Node script (or in this case, Gulp). The reference here, <code>cordova = require('cordova-lib').cordova.raw</code>, provides access to the Cordova&rsquo;s underlying API, exposing stuff like <code>build</code> and <code>emulate</code>.</p>

<p>It&rsquo;s not all unicorns mind; the API has auto-detection routine in place that works out the project&rsquo;s root directory. This only works however, if you&rsquo;re within Cordova&rsquo;s project structure. I&rsquo;m positive this can be overcome by &lsquo;cleaner&rsquo; methods of API abstraction, but for the moment I&rsquo;ve circumvented the issue by introducing two calls to <code>process.chdir</code>. <code>chdir</code> changes the working directory of running script. The second call resets the directory, for the purposes of possible task chaining.</p>

<p>See here:</p>

<pre><code class="js">gulp.task('emulate', [ 'compile' ], function(cb) {
    process.chdir(__dirname + '/cordova');
    cordova
        .run({ platforms: [ 'ios' ] })
        .then(function() {
            process.chdir('../');
            cb();
        });
});
</code></pre>

<ol>
<li>We change the directory.</li>
<li>We call <code>run</code>. <code>emulate</code> is an alias for <code>run</code>.</li>
<li>When the <code>run</code> process completes, the directory is reset.</li>
</ol>


<p>So there you have it, in a single Gulp command you can, transpile, populate, build and emulate. For me, this little nugget has sped up my workflow, and has made the build task more approachable to other developers working on the project.</p>
]]></content>
  </entry>
  
</feed>
