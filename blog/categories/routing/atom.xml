<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Routing | Adventures in brine]]></title>
  <link href="http://rich.k3r.me/blog/categories/routing/atom.xml" rel="self"/>
  <link href="http://rich.k3r.me/"/>
  <updated>2015-06-16T23:29:45+01:00</updated>
  <id>http://rich.k3r.me/</id>
  <author>
    <name><![CDATA[Richard Kimber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Async/await, Readable Non-blocking Code]]></title>
    <link href="http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code/"/>
    <updated>2015-06-16T23:06:49+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/06/16/async-slash-await-readable-non-blocking-code</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> Shit just got streamlined. More specifically, promises start looking cleaner when you spray them with &lsquo;Callbacks Begone&rsquo;.</em></p>

<p>In this post I&rsquo;m going to give you a quick demo of how easy it is to incorporate ES7&rsquo;s proposed <a href="https://github.com/lukehoban/ecmascript-asyncawait">Async/Await</a> functionality into your existing ES6 code. To build the code, I&rsquo;m using <a href="https://babeljs.io/">Babel</a> with &lsquo;es7.asyncFunctions&rsquo; enabled. You can read about my <a href="https://github.com/gulpjs/gulp">Gulp</a> setup <a href="/blog/2015/03/23/in-the-name-of-gulp/">here</a>.</p>

<!-- More -->


<p>Consider the code below:</p>

<pre><code class="js">function asyncFuncA() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncA'); }, 2000);
  });
}

function asyncFuncB() {
  return new Promise(function(r) {
    setTimeout(() =&gt; { r('asyncB'); }, 1000);
  });
}

class AsyncController {

  render(template, data) {
    return new Promise(function(resolve, reject) {
      // Do render stuff
      resolve({ t: template, d: data });
    });
  }

  asyncAction(route) {
    return asyncFuncA()
      .then(function(a) {
        return asyncFuncB()
          .then(b =&gt; { return [ a, b ]; });
      })
      .then(data =&gt; { return this.render('route', data); });
  }

}

let c = new AsyncController();

c.asyncAction()
  .then((obj) =&gt; { console.log(`${obj.d[0]} + ${obj.d[1]}`); });
</code></pre>

<p>We&rsquo;re looking at a Controller class with a couple of actions. The <code>asyncAction</code> function of <code>AsyncController</code> is what we&rsquo;re interested in. The action resolves two promises, one after the other, before calling <code>render</code> with the results of the two promises. In a <a href="/blog/2015/04/29/empty-promises-dos-and-donts-of-es6-promises/">previous article</a>, we already removed a couple of callbacks with <code>Promise.all</code>.</p>

<pre><code class="js"> asyncAction(route) {
    return Promise.all([ asyncFuncA(), asyncFuncB() ])
      .then(data =&gt; { return this.render('route', data); });
  }
</code></pre>

<p>A lot cleaner, but we can do better. <code>async</code> and <code>await</code> are keywords that, when used together, allow you to write asynchronous code without callbacks. <code>async</code> creates a container, within which you can execute promises (prefixed with <code>await</code>) that halt the current scope, until the promises have resolved. The resulting values of said promises are returned in the same way would expect a synchronous function to behave.</p>

<p>What is important, is that this only happens within the <code>async</code> container, which is itself becomes a promise. In the following example <code>p</code> and <code>a</code> are roughly equivalent.</p>

<pre><code class="js">function p() {
  return Promise.resolve('hello world');
}

async function a() {
  return 'hello world';
}

p().then((r) =&gt; { console.log(r); });
a().then((r) =&gt; { console.log(r); });
</code></pre>

<p>What I think is particularly neat, is that class functions can also be decorated with <code>async</code>. So we can use this &lsquo;syntastical&rsquo; sugar on our original example to create:</p>

<pre><code class="js">  async asyncAction(route) {
    return this.render(route, [ await asyncFuncA(), await asyncFuncB() ]);
  }
</code></pre>

<p>The code above is equivalent to the <code>asyncAction</code> functions of the previous examples. I mean, pure, wow factor. It&rsquo;s so awesome, I&rsquo;m giddy. Deep breaths, carry on. <code>asyncFuncA</code> and <code>asyncFuncB</code> are both functions that return promises. These promises both return simple strings, after different timeout periods, during which time the <code>asyncAction</code> function&rsquo;s execution is halted. After the promises has resolved, the final value is returned to current scope and execution continues, as if the <code>await</code> functions were synchronous.</p>

<p>This new functionality has taken promises to a whole new level for me. The <code>async</code> function by itself, removes the need for repetitive <code>Promise</code> declarations. Combined with <code>await</code>, we get asynchronous code that is as easy to read as synchronous code. And no callbacks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Routing With JavaScript Decorators]]></title>
    <link href="http://rich.k3r.me/blog/2015/05/20/simple-routing-with-javascript-decorators/"/>
    <updated>2015-05-20T22:30:57+01:00</updated>
    <id>http://rich.k3r.me/blog/2015/05/20/simple-routing-with-javascript-decorators</id>
    <content type="html"><![CDATA[<p><em><strong>TL;DR:</strong> I&rsquo;ve used decorators to generate a bunch of routes from a class.</em></p>

<p>I can&rsquo;t decide whether this is a legitimate use for decorators, but I knew from the moment I saw this crazy syntax that this was want I wanted to achieve.</p>

<!-- More -->


<h2>What&rsquo;s what?</h2>

<p>In a lot of my app projects, I chuck my actions into a series of classes which extend a simple class called <code>Controller</code>. My old code for <code>Controller</code> is below and as you can see, it exposes an empty array of actions.</p>

<pre><code class="javascript">class Controller {

    actions() {
        return [];
    }

    constructor(app = {}) {
        this.app = app;
    }

}
</code></pre>

<p>The idea is that in the extended class, you add &lsquo;action&rsquo; functions, that you then list in the overridden array. See the example <code>NotesController</code> below.</p>

<pre><code class="javascript">class NotesController extends Controller {

    actions() {
        return [
            { match: 'note', action: 'show' },
            { match: 'notes/create', action: 'create' },
            { match: 'notes/new', action: 'new' }
        ];
    }

    show(id) {

    }

    create(params, data, $form) {

    }

    new() {

    }

    doSomethingUseful() {

    }

}
</code></pre>

<p><code>NotesController</code> now advertises which routes it&rsquo;s setup to listen to. Any function not listed n the array is ignored and assumed to be a helper method of some kind. This has alway felt a bit clunky, specifically I didn&rsquo;t like:</p>

<ol>
<li>Overriding a function, whose sole purpose to create and return a new array each time it&rsquo;s called. During the application lifecycle it&rsquo;s typically only called once, but that&rsquo;s not the point. I could have used class properties, but it&rsquo;s still quite a new feature for Babel. I could have used <a href="http://www.typescriptlang.org/">TypeScript</a> I guess, but <a href="http://www.sublimetext.com/3">Sublime Text</a> tooling for TS has not been a positive experience and I&rsquo;m not ready to switch to <a href="https://code.visualstudio.com/">Visual Studio Code</a>, yet.</li>
<li>The repetition of writing a function, then list it in an array. #boring.</li>
</ol>


<h2>So, what&rsquo;s what now?</h2>

<p>Glad you asked. I&rsquo;ve basically ripped off the <code>autobind</code> example from the <a href="http://babeljs.io/blog/2015/03/31/5.0.0/#stage-1:-decorators">Babel 5.0.0 blog post</a> and created  a new decorator called <code>route</code>. Checkout the code for <code>route</code> below.</p>

<pre><code class="javascript">function route(route) {
    return function(target, key, descriptor) {
        var fn = descriptor.value;

        delete descriptor.value;
        delete descriptor.writable;

        if (!route) {
            route = key;
        }

        descriptor.get = function() {
            var bound = fn.bind(this, route);

            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                value: bound
            });

            return bound;
        };

        if (!target.routes) {
            target.routes = [];
        }

        target.routes.push({ match: route, action: key });

    };
}
</code></pre>

<p>The differences between this decorator and the <code>autobind</code> example are:</p>

<ol>
<li><code>route</code> takes an optional parameter (also called <code>route</code>), that allows you to specify the route to be matched. Optional, in that if missed out, the decorator assumes the name of the action, is also the route.</li>
<li>An array of the routes is managed on the instance of the controller, so the array is an instance property now.</li>
<li>I&rsquo;m passing the <code>route</code> param to the function, as it&rsquo;s often useful to know the route in the function.</li>
</ol>


<p>Let&rsquo;s see the new code:</p>

<pre><code class="javascript">// Controller Class
class Controller {

    constructor(app = {}) {
        this.app = app;

        // In case no routes are specified
        if (!this.routes) {
            this.routes = [];
        }
    }

}

// NotesController Class
class NotesController extends Controller {

    @route('note')
    show(id) {

    }

    @route('notes/create')
    create(params, data, $form) {

    }

    @route()
    new() {

    }

    doSomethingUseful() {

    }

}
</code></pre>

<p>You can see, no more <code>actions</code> function, no more verbose listing of the functions. I&rsquo;ve intentionally left out the value of the <code>new</code> route, to demonstrate how the &lsquo;implied&rsquo; routing works. If you run the code above in the Babel <a href="http://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=function%20route(route)%20%7B%0A%09return%20function(target%2C%20key%2C%20descriptor)%20%7B%0A%09%09var%20fn%20%3D%20descriptor.value%3B%0A%0A%09%09delete%20descriptor.value%3B%0A%09%09delete%20descriptor.writable%3B%0A%0A%09%09if%20(!route)%20%7B%0A%09%09%09route%20%3D%20key%3B%0A%09%09%7D%0A%0A%09%09descriptor.get%20%3D%20function()%20%7B%0A%09%09%09var%20bound%20%3D%20fn.bind(this%2C%20route)%3B%0A%0A%09%09%09Object.defineProperty(this%2C%20key%2C%20%7B%0A%09%09%09%09configurable%3A%20true%2C%0A%09%09%09%09writable%3A%20true%2C%0A%09%09%09%09value%3A%20bound%0A%09%09%09%7D)%3B%0A%0A%09%09%09return%20bound%3B%0A%09%09%7D%3B%0A%0A%09%09if%20(!target.routes)%20%7B%0A%09%09%09target.routes%20%3D%20%5B%5D%3B%0A%09%09%7D%0A%0A%09%09target.routes.push(%7B%20match%3A%20route%2C%20action%3A%20key%20%7D)%3B%0A%0A%09%7D%3B%0A%7D%0A%0Aclass%20Controller%20%7B%0A%0A%09constructor(app%20%3D%20%7B%7D)%20%7B%0A%09%09this.app%20%3D%20app%3B%0A%0A%09%09if%20(!this.routes)%20%7B%0A%09%09%09this.routes%20%3D%20%5B%5D%3B%0A%09%09%7D%0A%09%7D%0A%0A%7D%0A%0A%2F%2F%20NotesController%20Class%0Aclass%20NotesController%20extends%20Controller%20%7B%0A%0A%09%40route('note')%0A%09show(id)%20%7B%0A%0A%09%7D%0A%0A%09%40route('notes%2Fcreate')%0A%09create(params%2C%20data%2C%20%24form)%20%7B%0A%0A%09%7D%0A%0A%09%40route()%0A%09new()%20%7B%0A%0A%09%7D%0A%09%0A%09doSomethingUseful()%20%7B%0A%09%0A%09%7D%0A%0A%7D%0A%0Aconsole.log(new%20NotesController().routes)">REPL</a>, you should get the output below:</p>

<pre><code class="javascript">[
    {"match":"note","action":"show"},
    {"match":"notes/create","action":"create"},
    {"match":"new","action":"new"}
]
</code></pre>

<p>With the exception of <code>new</code>, the array is identical to that of the first example. That be some nice ass syntactic sugar. The future rocks. Peace out.</p>
]]></content>
  </entry>
  
</feed>
